import requests
import json
import time
from typing import Dict, List, Optional, Any
from concurrent.futures import ThreadPoolExecutor
import re

class MultiSourceVulnerabilityScanner:
    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
        
        # Rate limiting
        self.last_request_time = {}
        
    def scan_vulnerabilities(self, service: str, version: str = None, port: int = None, 
                           banner: str = None) -> Dict[str, Any]:
        """
        Multi-source vulnerability scanning with better reliability
        """
        results = {
            'vulnerabilities': [],
            'sources_used': [],
            'confidence': 'medium',
            'total_found': 0
        }
        
        # Use multiple sources in parallel
        sources = [
            self._query_nvd_nist,
            self._query_cvedetails,
            self._query_shodan_cvedb,
            self._query_cisa_kev,
            self._query_exploit_db
        ]
        
        all_vulnerabilities = []
        
        with ThreadPoolExecutor(max_workers=3) as executor:
            futures = []
            
            for source_func in sources:
                try:
                    future = executor.submit(source_func, service, version, port, banner)
                    futures.append((source_func.__name__, future))
                except Exception as e:
                    print(f"Error submitting {source_func.__name__}: {e}")
            
            for source_name, future in futures:
                try:
                    source_result = future.result(timeout=10)
                    if source_result['vulnerabilities']:
                        all_vulnerabilities.extend(source_result['vulnerabilities'])
                        results['sources_used'].append(source_name)
                        print(f"✓ {source_name}: {len(source_result['vulnerabilities'])} vulnerabilities")
                    else:
                        print(f"✗ {source_name}: No vulnerabilities found")
                except Exception as e:
                    print(f"✗ {source_name}: Error - {e}")
        
        # Deduplicate and sort
        results['vulnerabilities'] = self._deduplicate_vulnerabilities(all_vulnerabilities)
        results['total_found'] = len(results['vulnerabilities'])
        
        # Set confidence based on number of sources
        if len(results['sources_used']) >= 3:
            results['confidence'] = 'high'
        elif len(results['sources_used']) >= 2:
            results['confidence'] = 'medium'
        else:
            results['confidence'] = 'low'
        
        return results
    
    def _rate_limit(self, source: str, min_interval: float = 1.0):
        """Simple rate limiting"""
        now = time.time()
        if source in self.last_request_time:
            time_passed = now - self.last_request_time[source]
            if time_passed < min_interval:
                time.sleep(min_interval - time_passed)
        self.last_request_time[source] = time.time()
    
    def _query_nvd_nist(self, service: str, version: str = None, port: int = None, 
                       banner: str = None) -> Dict[str, Any]:
        """
        Query NIST NVD API - Most reliable source
        """
        self._rate_limit('nvd', 1.5)  # NVD has strict rate limits
        
        try:
            base_url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
            
            # Build search query
            search_terms = []
            if service:
                search_terms.append(service.lower())
            if version:
                search_terms.append(version)
            
            if not search_terms:
                return {'vulnerabilities': []}
            
            # Search by keyword
            params = {
                'keywordSearch': ' '.join(search_terms),
                'resultsPerPage': 50,
                'startIndex': 0
            }
            
            response = self.session.get(base_url, params=params, timeout=10)
            response.raise_for_status()
            
            data = response.json()
            vulnerabilities = []
            
            if 'vulnerabilities' in data:
                for vuln_item in data['vulnerabilities']:
                    cve = vuln_item.get('cve', {})
                    
                    # Extract CVSS score
                    cvss_score = 0.0
                    cvss_vector = ""
                    
                    metrics = cve.get('metrics', {})
                    if 'cvssMetricV31' in metrics:
                        cvss_data = metrics['cvssMetricV31'][0]['cvssData']
                        cvss_score = cvss_data.get('baseScore', 0.0)
                        cvss_vector = cvss_data.get('vectorString', '')
                    elif 'cvssMetricV2' in metrics:
                        cvss_data = metrics['cvssMetricV2'][0]['cvssData']
                        cvss_score = cvss_data.get('baseScore', 0.0)
                        cvss_vector = cvss_data.get('vectorString', '')
                    
                    vuln = {
                        'id': cve.get('id', ''),
                        'description': cve.get('descriptions', [{}])[0].get('value', ''),
                        'cvss_score': cvss_score,
                        'cvss_vector': cvss_vector,
                        'published_date': cve.get('published', ''),
                        'modified_date': cve.get('lastModified', ''),
                        'source': 'NIST_NVD',
                        'references': [ref.get('url', '') for ref in cve.get('references', [])],
                        'severity': self._get_severity_from_cvss(cvss_score)
                    }
                    
                    vulnerabilities.append(vuln)
            
            return {'vulnerabilities': vulnerabilities}
            
        except Exception as e:
            print(f"NVD query error: {e}")
            return {'vulnerabilities': []}
    
    def _query_shodan_cvedb(self, service: str, version: str = None, port: int = None, 
                           banner: str = None) -> Dict[str, Any]:
        """
        Query Shodan's free CVEDB API - Very good and free!
        """
        self._rate_limit('shodan_cvedb', 0.5)
        
        try:
            if not service:
                return {'vulnerabilities': []}
            
            # Shodan CVEDB search
            search_query = service.lower()
            if version:
                search_query += f" {version}"
            
            url = f"https://cvedb.shodan.io/cves"
            params = {
                'product': service.lower(),
                'version': version if version else '',
                'limit': 50
            }
            
            response = self.session.get(url, params=params, timeout=8)
            response.raise_for_status()
            
            data = response.json()
            vulnerabilities = []
            
            if isinstance(data, list):
                for cve_item in data:
                    vuln = {
                        'id': cve_item.get('cve_id', ''),
                        'description': cve_item.get('summary', ''),
                        'cvss_score': float(cve_item.get('cvss', 0)),
                        'published_date': cve_item.get('publish_date', ''),
                        'source': 'Shodan_CVEDB',
                        'references': cve_item.get('references', []),
                        'severity': self._get_severity_from_cvss(float(cve_item.get('cvss', 0)))
                    }
                    vulnerabilities.append(vuln)
            
            return {'vulnerabilities': vulnerabilities}
            
        except Exception as e:
            print(f"Shodan CVEDB error: {e}")
            return {'vulnerabilities': []}
    
    def _query_cvedetails(self, service: str, version: str = None, port: int = None, 
                         banner: str = None) -> Dict[str, Any]:
        """
        Query CVEDetails (scraping-based, use carefully)
        """
        self._rate_limit('cvedetails', 2.0)
        
        try:
            if not service:
                return {'vulnerabilities': []}
            
            # CVEDetails search by product
            search_url = "https://www.cvedetails.com/product-search.php"
            params = {
                'search': service,
                'vendor': '',
                'version': version if version else ''
            }
            
            response = self.session.get(search_url, params=params, timeout=10)
            
            # This would require HTML parsing - simplified for example
            # In production, you'd use BeautifulSoup to parse results
            vulnerabilities = []
            
            # For now, return empty (implement HTML parsing if needed)
            return {'vulnerabilities': vulnerabilities}
            
        except Exception as e:
            print(f"CVEDetails error: {e}")
            return {'vulnerabilities': []}
    
    def _query_cisa_kev(self, service: str, version: str = None, port: int = None, 
                       banner: str = None) -> Dict[str, Any]:
        """
        Query CISA Known Exploited Vulnerabilities - Critical ones only
        """
        self._rate_limit('cisa_kev', 1.0)
        
        try:
            url = "https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json"
            response = self.session.get(url, timeout=10)
            response.raise_for_status()
            
            data = response.json()
            vulnerabilities = []
            
            if 'vulnerabilities' in data:
                service_lower = service.lower() if service else ""
                
                for kev_item in data['vulnerabilities']:
                    # Check if this CVE relates to our service
                    vuln_name = kev_item.get('vulnerabilityName', '').lower()
                    product = kev_item.get('product', '').lower()
                    
                    if (service_lower in vuln_name or 
                        service_lower in product or 
                        any(service_lower in ref.lower() for ref in kev_item.get('references', []))):
                        
                        vuln = {
                            'id': kev_item.get('cveID', ''),
                            'description': kev_item.get('vulnerabilityName', ''),
                            'cvss_score': 9.0,  # KEV items are high priority
                            'published_date': kev_item.get('dateAdded', ''),
                            'due_date': kev_item.get('dueDate', ''),
                            'source': 'CISA_KEV',
                            'exploited_in_wild': True,
                            'severity': 'CRITICAL',
                            'required_action': kev_item.get('requiredAction', '')
                        }
                        vulnerabilities.append(vuln)
            
            return {'vulnerabilities': vulnerabilities}
            
        except Exception as e:
            print(f"CISA KEV error: {e}")
            return {'vulnerabilities': []}
    
    def _query_exploit_db(self, service: str, version: str = None, port: int = None, 
                         banner: str = None) -> Dict[str, Any]:
        """
        Query Exploit-DB for known exploits
        """
        self._rate_limit('exploit_db', 1.5)
        
        try:
            # Exploit-DB search API
            if not service:
                return {'vulnerabilities': []}
            
            search_term = service
            if version:
                search_term += f" {version}"
            
            # Using their CSV endpoint which is more reliable
            url = f"https://gitlab.com/exploit-database/exploitdb/-/raw/main/files_exploits.csv"
            
            # For this example, we'll return empty
            # In production, you'd parse the CSV and search for matches
            vulnerabilities = []
            
            return {'vulnerabilities': vulnerabilities}
            
        except Exception as e:
            print(f"Exploit-DB error: {e}")
            return {'vulnerabilities': []}
    
    def _get_severity_from_cvss(self, cvss_score: float) -> str:
        """Convert CVSS score to severity level"""
        if cvss_score >= 9.0:
            return "CRITICAL"
        elif cvss_score >= 7.0:
            return "HIGH"
        elif cvss_score >= 4.0:
            return "MEDIUM"
        elif cvss_score > 0.0:
            return "LOW"
        else:
            return "INFO"
    
    def _deduplicate_vulnerabilities(self, vulnerabilities: List[Dict]) -> List[Dict]:
        
        seen_cves = {}
        
        for vuln in vulnerabilities:
            cve_id = vuln.get('id', '')
            if cve_id and cve_id not in seen_cves:
                seen_cves[cve_id] = vuln
            elif cve_id in seen_cves:
                # Keep the one with more complete information
                existing = seen_cves[cve_id]
                if len(str(vuln.get('description', ''))) > len(str(existing.get('description', ''))):
                    seen_cves[cve_id] = vuln
        
        # Sort by CVSS score (highest first)
        sorted_vulns = sorted(
            seen_cves.values(),
            key=lambda v: v.get('cvss_score', 0),
            reverse=True
        )
        
        return sorted_vulns


# Integration with your existing code
def enhanced_vulnerability_scan(hosts):
    """
    Enhanced vulnerability scanning using multiple reliable sources
    """
    vuln_scanner = MultiSourceVulnerabilityScanner()
    
    total_vulns_found = 0
    
    for host in hosts:
        ip = host["ip"]
        print(f"\n🔍 Scanning vulnerabilities for host: {ip}")
        
        for svc in host["services"]:
            port = svc["port"]
            service = svc.get("service") or svc.get("product", "")
            version = svc.get("version", "")
            banner = svc.get("banner", "")
            
            if not service:
                print(f"  ⚠️  Port {port}: No service identified, skipping vulnerability scan")
                continue
            
            print(f"  🎯 Port {port} ({service} {version}): Scanning...")
            
            # Scan vulnerabilities using multiple sources
            vuln_results = vuln_scanner.scan_vulnerabilities(
                service=service,
                version=version,
                port=port,
                banner=banner
            )
            
            # Add results to service
            svc["vulnerabilities"] = vuln_results["vulnerabilities"]
            svc["vuln_sources"] = vuln_results["sources_used"]
            svc["vuln_confidence"] = vuln_results["confidence"]
            svc["vuln_count"] = vuln_results["total_found"]
            
            total_vulns_found += vuln_results["total_found"]
            
            # Print summary
            if vuln_results["total_found"] > 0:
                print(f"    ✅ Found {vuln_results['total_found']} vulnerabilities")
                print(f"    📊 Sources: {', '.join(vuln_results['sources_used'])}")
                print(f"    🎯 Confidence: {vuln_results['confidence']}")
                
                # Show top vulnerability
                if vuln_results["vulnerabilities"]:
                    top_vuln = vuln_results["vulnerabilities"][0]
                    print(f"    🚨 Top: {top_vuln['id']} (CVSS: {top_vuln.get('cvss_score', 'N/A')}) - {top_vuln.get('severity', 'UNKNOWN')}")
            else:
                print(f"    ℹ️  No vulnerabilities found")
    
    print(f"\n📈 Total vulnerabilities found across all hosts: {total_vulns_found}")
    return hosts

