import requests
import json
import time
from typing import Dict, List, Optional, Any
from concurrent.futures import ThreadPoolExecutor
import re
from datetime import datetime, timedelta
from urllib.parse import quote

class MultiSourceVulnerabilityScanner:
    def __init__(self, shodan_api_key: str = None):
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        })
        
        # API keys (optional but recommended)
        self.shodan_api_key = shodan_api_key
        
        # Rate limiting
        self.last_request_time = {}
        
        # Cache for CISA KEV data (loaded once)
        self.cisa_kev_cache = None
        self.cisa_kev_loaded = False
        
    def scan_vulnerabilities(self, service: str, version: str = None, port: int = None, 
                           banner: str = None) -> Dict[str, Any]:
        """
        Multi-source vulnerability scanning with improved reliability
        """
        results = {
            'vulnerabilities': [],
            'sources_used': [],
            'confidence': 'medium',
            'total_found': 0,
            'search_strategy': 'version_specific' if version else 'service_generic'
        }
        
        print(f"Scanning {service} {version or '(no version)'}")
        
        # Use multiple sources with improved error handling
        sources = [
            ('NVD_NIST', self._query_nvd_nist),
            ('CVE_CircL', self._query_circl_cve),
            ('CISA_KEV', self._query_cisa_kev),
            ('VulnDB_API', self._query_vulndb_api),
            ('OSV_API', self._query_osv_api),
            ('SecurityVuln_API', self._query_securityvuln_api)  # New addition from testvuln.py
        ]
        
        all_vulnerabilities = []
        
        # If no version, get recent vulnerabilities for the service
        if not version:
            print("No version specified - searching for recent vulnerabilities")
            results['search_strategy'] = 'recent_generic'
        
        with ThreadPoolExecutor(max_workers=3) as executor:
            futures = []
            
            for source_name, source_func in sources:
                try:
                    future = executor.submit(source_func, service, version, port, banner)
                    futures.append((source_name, future))
                except Exception as e:
                    print(f"Error submitting {source_name}: {e}")
            
            for source_name, future in futures:
                try:
                    source_result = future.result(timeout=15)
                    if source_result and source_result.get('vulnerabilities'):
                        all_vulnerabilities.extend(source_result['vulnerabilities'])
                        results['sources_used'].append(source_name)
                        print(f"{source_name}: {len(source_result['vulnerabilities'])} vulnerabilities")
                    else:
                        print(f"{source_name}: No vulnerabilities found")
                except Exception as e:
                    print(f"{source_name}: Error - {e}")
        
        # Deduplicate and sort
        results['vulnerabilities'] = self._deduplicate_vulnerabilities(all_vulnerabilities)
        results['total_found'] = len(results['vulnerabilities'])
        
        # If no version provided and we have results, limit to top 5 most recent
        if not version and results['vulnerabilities']:
            results['vulnerabilities'] = self._get_top_recent_vulnerabilities(
                results['vulnerabilities'], limit=5
            )
            results['total_found'] = len(results['vulnerabilities'])
            print(f"Limited to top {len(results['vulnerabilities'])} recent vulnerabilities")
        
        # Set confidence based on number of sources and data quality
        if len(results['sources_used']) >= 3:
            results['confidence'] = 'high'
        elif len(results['sources_used']) >= 2:
            results['confidence'] = 'medium'
        elif len(results['sources_used']) >= 1:
            results['confidence'] = 'low'
        else:
            results['confidence'] = 'none'
        
        return results
    
    def _rate_limit(self, source: str, min_interval: float = 1.0):
        """Improved rate limiting with backoff"""
        now = time.time()
        if source in self.last_request_time:
            time_passed = now - self.last_request_time[source]
            if time_passed < min_interval:
                sleep_time = min_interval - time_passed
                time.sleep(sleep_time)
        self.last_request_time[source] = time.time()
    
    def _query_nvd_nist(self, service: str, version: str = None, port: int = None, 
                       banner: str = None) -> Dict[str, Any]:
        """
        Query NIST NVD API 2.0 - Most reliable source
        """
        self._rate_limit('nvd', 2.0)  # NVD strict rate limits
        
        try:
            base_url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
            
            # Build search parameters
            params = {
                'resultsPerPage': 50 if version else 20,  # More results if no version
                'startIndex': 0
            }
            
            # Strategy 1: If we have version, search specifically
            if version:
                # Try CPE format first
                cpe_name = f"cpe:2.3:a:*:{service.lower()}:{version}:*:*:*:*:*:*:*"
                params['cpeName'] = cpe_name
                search_strategy = "cpe_specific"
            else:
                # Strategy 2: Keyword search for service only
                params['keywordSearch'] = service.lower()
                # Get recent vulnerabilities (last 2 years)
                two_years_ago = (datetime.now() - timedelta(days=730)).strftime('%Y-%m-%dT00:00:00.000')
                params['pubStartDate'] = two_years_ago
                search_strategy = "keyword_recent"
            
            print(f"  NVD strategy: {search_strategy}")
            response = self.session.get(base_url, params=params, timeout=15)
            
            if response.status_code == 403:
                print("  NVD rate limit hit, trying fallback search")
                # Fallback to basic keyword search
                params = {
                    'keywordSearch': service.lower(),
                    'resultsPerPage': 20
                }
                time.sleep(3)
                response = self.session.get(base_url, params=params, timeout=15)
            
            response.raise_for_status()
            data = response.json()
            vulnerabilities = []
            
            if 'vulnerabilities' in data:
                for vuln_item in data['vulnerabilities'][:20]:  # Limit results
                    cve = vuln_item.get('cve', {})
                    
                    # Extract CVSS score with fallback
                    cvss_score = 0.0
                    cvss_vector = ""
                    
                    metrics = cve.get('metrics', {})
                    if 'cvssMetricV31' in metrics and metrics['cvssMetricV31']:
                        cvss_data = metrics['cvssMetricV31'][0]['cvssData']
                        cvss_score = cvss_data.get('baseScore', 0.0)
                        cvss_vector = cvss_data.get('vectorString', '')
                    elif 'cvssMetricV30' in metrics and metrics['cvssMetricV30']:
                        cvss_data = metrics['cvssMetricV30'][0]['cvssData']
                        cvss_score = cvss_data.get('baseScore', 0.0)
                        cvss_vector = cvss_data.get('vectorString', '')
                    elif 'cvssMetricV2' in metrics and metrics['cvssMetricV2']:
                        cvss_data = metrics['cvssMetricV2'][0]['cvssData']
                        cvss_score = cvss_data.get('baseScore', 0.0)
                        cvss_vector = cvss_data.get('vectorString', '')
                    
                    # Get description
                    descriptions = cve.get('descriptions', [])
                    description = ""
                    for desc in descriptions:
                        if desc.get('lang') == 'en':
                            description = desc.get('value', '')
                            break
                    
                    vuln = {
                        'id': cve.get('id', ''),
                        'description': description,
                        'cvss_score': cvss_score,
                        'cvss_vector': cvss_vector,
                        'published_date': cve.get('published', ''),
                        'modified_date': cve.get('lastModified', ''),
                        'source': 'NIST_NVD',
                        'references': [ref.get('url', '') for ref in cve.get('references', [])],
                        'severity': self._get_severity_from_cvss(cvss_score),
                        'search_strategy': search_strategy
                    }
                    
                    vulnerabilities.append(vuln)
            
            print(f"  NVD returned {len(vulnerabilities)} vulnerabilities")
            return {'vulnerabilities': vulnerabilities}
            
        except Exception as e:
            print(f"NVD query error: {e}")
            return {'vulnerabilities': []}
    
    def _query_circl_cve(self, service: str, version: str = None, port: int = None, 
                        banner: str = None) -> Dict[str, Any]:
        """
        Query CIRCL CVE Search API - Good alternative to NVD
        """
        self._rate_limit('circl', 1.0)
        
        try:
            base_url = "https://cve.circl.lu/api"
            vulnerabilities = []
            
            if version:
                # Search by specific version
                search_url = f"{base_url}/search/{service}/{version}"
            else:
                # Browse recent CVEs for service
                search_url = f"{base_url}/browse/{service.lower()}"
            
            response = self.session.get(search_url, timeout=10)
            
            if response.status_code == 200:
                data = response.json()
                
                # Handle different response formats
                if isinstance(data, list):
                    cve_list = data
                elif isinstance(data, dict) and 'results' in data:
                    cve_list = data['results']
                else:
                    cve_list = [data] if data else []
                
                for cve_item in cve_list[:15]:  # Limit results
                    if isinstance(cve_item, str):
                        # If we just get CVE IDs, fetch details
                        cve_id = cve_item
                        cve_detail_url = f"{base_url}/cve/{cve_id}"
                        detail_response = self.session.get(cve_detail_url, timeout=5)
                        if detail_response.status_code == 200:
                            cve_data = detail_response.json()
                        else:
                            continue
                    else:
                        cve_data = cve_item
                    
                    # Extract vulnerability info
                    vuln = {
                        'id': cve_data.get('id', ''),
                        'description': cve_data.get('summary', ''),
                        'cvss_score': float(cve_data.get('cvss', 0)) if cve_data.get('cvss') else 0.0,
                        'published_date': cve_data.get('Published', ''),
                        'modified_date': cve_data.get('Modified', ''),
                        'source': 'CIRCL_CVE',
                        'references': cve_data.get('references', []),
                        'severity': self._get_severity_from_cvss(float(cve_data.get('cvss', 0)) if cve_data.get('cvss') else 0.0)
                    }
                    
                    vulnerabilities.append(vuln)
                    time.sleep(0.2)  # Small delay between detail requests
            
            print(f"  CIRCL returned {len(vulnerabilities)} vulnerabilities")
            return {'vulnerabilities': vulnerabilities}
            
        except Exception as e:
            print(f"CIRCL query error: {e}")
            return {'vulnerabilities': []}
    
    def _query_osv_api(self, service: str, version: str = None, port: int = None, 
                      banner: str = None) -> Dict[str, Any]:
        """
        Query Google's OSV (Open Source Vulnerabilities) API
        """
        self._rate_limit('osv', 0.5)
        
        try:
            url = "https://api.osv.dev/v1/query"
            
            # OSV query format
            if version:
                query_data = {
                    "package": {
                        "name": service.lower()
                    },
                    "version": version
                }
            else:
                # For no version, use broader ecosystem search
                query_data = {
                    "package": {
                        "name": service.lower()
                    }
                }
            
            response = self.session.post(url, json=query_data, timeout=10)
            
            if response.status_code != 200:
                return {'vulnerabilities': []}
            
            data = response.json()
            vulnerabilities = []
            
            if 'vulns' in data:
                for vuln_item in data['vulns'][:15]:  # Limit results
                    # Extract severity info
                    severity_info = vuln_item.get('severity', [])
                    cvss_score = 0.0
                    
                    for sev in severity_info:
                        if sev.get('type') == 'CVSS_V3':
                            cvss_score = float(sev.get('score', 0))
                            break
                        elif sev.get('type') == 'CVSS_V2':
                            cvss_score = float(sev.get('score', 0))
                    
                    vuln = {
                        'id': vuln_item.get('id', ''),
                        'description': vuln_item.get('summary', ''),
                        'cvss_score': cvss_score,
                        'published_date': vuln_item.get('published', ''),
                        'modified_date': vuln_item.get('modified', ''),
                        'source': 'OSV_Google',
                        'references': [ref.get('url', '') for ref in vuln_item.get('references', [])],
                        'severity': self._get_severity_from_cvss(cvss_score),
                        'affected_versions': [affected.get('versions', []) for affected in vuln_item.get('affected', [])]
                    }
                    
                    vulnerabilities.append(vuln)
            
            print(f"  OSV returned {len(vulnerabilities)} vulnerabilities")
            return {'vulnerabilities': vulnerabilities}
            
        except Exception as e:
            print(f"OSV query error: {e}")
            return {'vulnerabilities': []}
    
    def _query_vulndb_api(self, service: str, version: str = None, port: int = None, 
                         banner: str = None) -> Dict[str, Any]:
        """
        Query VulnDB free API endpoints
        """
        self._rate_limit('vulndb', 1.0)
        
        try:
            # Use the free search endpoint
            search_url = "https://vuldb.com/api/v1/search/"
            
            # Build search query
            search_query = service.lower()
            if version:
                search_query += f" {version}"
            
            params = {
                'search': search_query,
                'format': 'json'
            }
            
            response = self.session.get(search_url, params=params, timeout=10)
            
            # VulnDB often returns HTML even for API calls, so check content type
            if 'application/json' not in response.headers.get('content-type', ''):
                return {'vulnerabilities': []}
            
            data = response.json()
            vulnerabilities = []
            
            if isinstance(data, dict) and 'entries' in data:
                for entry in data['entries'][:10]:
                    vuln = {
                        'id': entry.get('id', ''),
                        'description': entry.get('title', ''),
                        'cvss_score': float(entry.get('cvss_score', 0)) if entry.get('cvss_score') else 0.0,
                        'published_date': entry.get('published', ''),
                        'source': 'VulnDB',
                        'severity': self._get_severity_from_cvss(float(entry.get('cvss_score', 0)) if entry.get('cvss_score') else 0.0)
                    }
                    vulnerabilities.append(vuln)
            
            print(f"  VulnDB returned {len(vulnerabilities)} vulnerabilities")
            return {'vulnerabilities': vulnerabilities}
            
        except Exception as e:
            print(f"VulnDB query error: {e}")
            return {'vulnerabilities': []}
    
    def _query_cisa_kev(self, service: str, version: str = None, port: int = None, 
                       banner: str = None) -> Dict[str, Any]:
        """
        Query CISA Known Exploited Vulnerabilities - Critical ones only
        """
        if not self.cisa_kev_loaded:
            self._load_cisa_kev_data()
        
        try:
            vulnerabilities = []
            
            if not self.cisa_kev_cache:
                return {'vulnerabilities': vulnerabilities}
            
            service_lower = service.lower() if service else ""
            version_lower = version.lower() if version else ""
            
            for kev_item in self.cisa_kev_cache:
                # Improved matching logic
                vuln_name = kev_item.get('vulnerabilityName', '').lower()
                product = kev_item.get('product', '').lower()
                vendor = kev_item.get('vendorProject', '').lower()
                
                # Check if this KEV relates to our service
                matches = (
                    service_lower in vuln_name or 
                    service_lower in product or 
                    service_lower in vendor or
                    any(service_lower in word for word in vuln_name.split()) or
                    any(service_lower in word for word in product.split())
                )
                
                if matches:
                    # If version specified, try to match it too
                    version_matches = True
                    if version:
                        version_matches = (
                            version_lower in vuln_name or
                            version_lower in product or
                            any(version_lower in word for word in vuln_name.split())
                        )
                    
                    if version_matches:
                        vuln = {
                            'id': kev_item.get('cveID', ''),
                            'description': kev_item.get('vulnerabilityName', ''),
                            'cvss_score': 9.5,  # KEV items are high priority by definition
                            'published_date': kev_item.get('dateAdded', ''),
                            'due_date': kev_item.get('dueDate', ''),
                            'source': 'CISA_KEV',
                            'exploited_in_wild': True,
                            'severity': 'CRITICAL',
                            'required_action': kev_item.get('requiredAction', ''),
                            'product': product,
                            'vendor': vendor
                        }
                        vulnerabilities.append(vuln)
            
            print(f"  CISA KEV returned {len(vulnerabilities)} vulnerabilities")
            return {'vulnerabilities': vulnerabilities}
            
        except Exception as e:
            print(f"CISA KEV error: {e}")
            return {'vulnerabilities': []}
    
    def _query_securityvuln_api(self, service: str, version: str = None, port: int = None, 
                               banner: str = None) -> Dict[str, Any]:
        """
        Query json.securityvulnerability.io API - Additional source from testvuln.py
        """
        self._rate_limit('securityvuln', 1.0)
        
        try:
            base_url = "https://json.securityvulnerability.io/search"
            
            # Construct query string
            if version:
                if version =="Unknown":
                    query = service
                else:

                    query = f"{service} {version}"
            else:
                query = service
                
            # Use quote to encode special characters but preserve spaces
            encoded_query = quote(query, safe=' ')
            url = f"{base_url}?query={encoded_query}"
            
            response = self.session.get(url, timeout=15)
            response.raise_for_status()
            
            # Parse JSON response
            data = response.json()
            vulnerabilities = []
            
            # Filter and process the results using helper methods from testvuln.py
            filtered_data = self._filter_securityvuln_data(data, service, version, 20)
            
            if filtered_data.get('cves'):
                for cve_item in filtered_data['cves']:
                    vuln = {
                        'id': cve_item.get('id', ''),
                        'description': cve_item.get('description', ''),
                        'cvss_score': cve_item.get('cvss_score', 0.0),
                        'published_date': cve_item.get('published_date', ''),
                        'modified_date': cve_item.get('modified_date', ''),
                        'source': 'SecurityVuln_API',
                        'references': cve_item.get('references', []),
                        'severity': cve_item.get('severity', 'UNKNOWN')
                    }
                    vulnerabilities.append(vuln)
            
            print(f"  SecurityVuln returned {len(vulnerabilities)} vulnerabilities")
            return {'vulnerabilities': vulnerabilities}
            
        except Exception as e:
            print(f"SecurityVuln query error: {e}")
            return {'vulnerabilities': []}
    
    def _filter_securityvuln_data(self, raw_data: Any, service_name: str, version: str, max_results: int) -> Dict[str, Any]:
        """
        Filter and structure the CVE data from the SecurityVuln API response
        Enhanced from testvuln.py
        """
        filtered_result = {
            "service": service_name,
            "version": version,
            "total_found": 0,
            "cves": []
        }
        
        # Handle different response formats
        cve_list = []
        
        if isinstance(raw_data, dict):
            # Check common keys where CVEs might be stored
            for key in ['cves', 'vulnerabilities', 'results', 'data', 'items']:
                if key in raw_data and isinstance(raw_data[key], list):
                    cve_list = raw_data[key]
                    break
            
            # If no list found, check if the entire dict represents a single CVE
            if not cve_list and any(k.upper().startswith('CVE') for k in raw_data.keys()):
                cve_list = [raw_data]
                
        elif isinstance(raw_data, list):
            cve_list = raw_data
        
        # Process each CVE entry
        processed_cves = []
        for idx, cve_item in enumerate(cve_list[:max_results]):
            if isinstance(cve_item, dict):
                processed_cve = self._extract_securityvuln_cve_info(cve_item)
                if processed_cve:
                    processed_cves.append(processed_cve)
        
        filtered_result["cves"] = processed_cves
        filtered_result["total_found"] = len(processed_cves)
        
        return filtered_result
    
    def _extract_securityvuln_cve_info(self, cve_item: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """
        Extract standardized CVE information from a single CVE entry
        Enhanced from testvuln.py
        """
        # Common field mappings for different API response formats
        field_mappings = {
            'id': ['id', 'cve', 'cve_id', 'CVE', 'identifier'],
            'description': ['description', 'summary', 'desc', 'details'],
            'cvss_score': ['cvss', 'cvss_score', 'score', 'severity_score'],
            'severity': ['severity', 'level', 'criticality'],
            'published': ['published', 'publication_date', 'date', 'published_date'],
            'modified': ['modified', 'last_modified', 'updated', 'modification_date'],
            'references': ['references', 'refs', 'links', 'urls']
        }
        
        extracted_info = {}
        
        # Extract fields using mapping
        for standard_key, possible_keys in field_mappings.items():
            for key in possible_keys:
                if key in cve_item:
                    extracted_info[standard_key] = cve_item[key]
                    break
        
        # Only return if we found at least an ID or description
        if extracted_info.get('id') or extracted_info.get('description'):
            # Ensure we have basic structure
            result = {
                'id': extracted_info.get('id', 'Unknown'),
                'description': extracted_info.get('description', 'No description available'),
                'cvss_score': self._normalize_cvss_score(extracted_info.get('cvss_score')),
                'severity': self._normalize_severity(extracted_info.get('severity')),
                'published_date': extracted_info.get('published', 'Unknown'),
                'modified_date': extracted_info.get('modified', 'Unknown'),
                'references': self._normalize_references(extracted_info.get('references', []))
            }
            return result
        
        return None
    
    def _normalize_cvss_score(self, score: Any) -> float:
        """Normalize CVSS score to float - from testvuln.py"""
        if score is None:
            return 0.0
        try:
            if isinstance(score, (int, float)):
                return float(score)
            elif isinstance(score, str):
                # Extract numeric value from string
                match = re.search(r'(\d+\.?\d*)', score)
                if match:
                    return float(match.group(1))
            return 0.0
        except:
            return 0.0
    
    def _normalize_severity(self, severity: Any) -> str:
        """Normalize severity to standard levels - from testvuln.py"""
        if not severity:
            return "UNKNOWN"
        
        severity_str = str(severity).upper()
        
        # Map various severity formats to standard levels
        if any(word in severity_str for word in ['CRITICAL', 'CRIT']):
            return "CRITICAL"
        elif any(word in severity_str for word in ['HIGH', 'SEVERE']):
            return "HIGH"
        elif any(word in severity_str for word in ['MEDIUM', 'MED', 'MODERATE']):
            return "MEDIUM"
        elif any(word in severity_str for word in ['LOW', 'MINOR']):
            return "LOW"
        elif any(word in severity_str for word in ['INFO', 'INFORMATIONAL']):
            return "INFO"
        else:
            return severity_str
    
    def _normalize_references(self, references: Any) -> List[str]:
        """Normalize references to list of URLs - from testvuln.py"""
        if not references:
            return []
        
        if isinstance(references, str):
            return [references]
        elif isinstance(references, list):
            ref_list = []
            for ref in references:
                if isinstance(ref, str):
                    ref_list.append(ref)
                elif isinstance(ref, dict) and 'url' in ref:
                    ref_list.append(ref['url'])
            return ref_list
        
        return []
    
    def _load_cisa_kev_data(self):
        """Load CISA KEV data once and cache it"""
        try:
            self._rate_limit('cisa_kev_load', 2.0)
            url = "https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json"
            response = self.session.get(url, timeout=15)
            response.raise_for_status()
            
            data = response.json()
            self.cisa_kev_cache = data.get('vulnerabilities', [])
            self.cisa_kev_loaded = True
            print(f"  Loaded {len(self.cisa_kev_cache)} CISA KEV entries")
            
        except Exception as e:
            print(f"Failed to load CISA KEV data: {e}")
            self.cisa_kev_cache = []
            self.cisa_kev_loaded = True
    
    def _get_top_recent_vulnerabilities(self, vulnerabilities: List[Dict], limit: int = 5) -> List[Dict]:
        """
        Get top N most recent vulnerabilities when version is not available
        """
        # Sort by published date (most recent first) and CVSS score
        def sort_key(vuln):
            pub_date = vuln.get('published_date', '')
            cvss = vuln.get('cvss_score', 0)
            
            # Parse date for sorting
            try:
                if pub_date:
                    # Handle different date formats
                    for fmt in ['%Y-%m-%dT%H:%M:%S.%fZ', '%Y-%m-%dT%H:%M:%SZ', '%Y-%m-%d']:
                        try:
                            parsed_date = datetime.strptime(pub_date.split('T')[0], '%Y-%m-%d')
                            return (parsed_date, cvss)
                        except:
                            continue
                return (datetime.min, cvss)
            except:
                return (datetime.min, cvss)
        
        sorted_vulns = sorted(vulnerabilities, key=sort_key, reverse=True)
        return sorted_vulns[:limit]
    
    def _get_severity_from_cvss(self, cvss_score: float) -> str:
        """Convert CVSS score to severity level (CVSS v3.1 standard)"""
        if cvss_score >= 9.0:
            return "CRITICAL"
        elif cvss_score >= 7.0:
            return "HIGH"
        elif cvss_score >= 4.0:
            return "MEDIUM"
        elif cvss_score > 0.0:
            return "LOW"
        else:
            return "INFO"
    
    def _deduplicate_vulnerabilities(self, vulnerabilities: List[Dict]) -> List[Dict]:
        """
        Improved deduplication with better merging logic
        """
        seen_cves = {}
        
        for vuln in vulnerabilities:
            cve_id = vuln.get('id', '')
            if not cve_id:
                continue
                
            if cve_id not in seen_cves:
                seen_cves[cve_id] = vuln
            else:
                # Merge information from multiple sources
                existing = seen_cves[cve_id]
                
                # Keep the one with higher CVSS score
                if vuln.get('cvss_score', 0) > existing.get('cvss_score', 0):
                    seen_cves[cve_id] = vuln
                
                # Merge references
                existing_refs = set(existing.get('references', []))
                new_refs = set(vuln.get('references', []))
                merged_refs = list(existing_refs.union(new_refs))
                seen_cves[cve_id]['references'] = merged_refs
                
                # Keep the longer description
                if len(str(vuln.get('description', ''))) > len(str(existing.get('description', ''))):
                    seen_cves[cve_id]['description'] = vuln.get('description', '')
        
        # Sort by CVSS score (highest first), then by date
        def sort_key(vuln):
            cvss = vuln.get('cvss_score', 0)
            pub_date = vuln.get('published_date', '')
            
            # Parse date for sorting
            try:
                if pub_date:
                    parsed_date = datetime.strptime(pub_date.split('T')[0], '%Y-%m-%d')
                    return (cvss, parsed_date)
            except:
                pass
            
            return (cvss, datetime.min)
        
        sorted_vulns = sorted(seen_cves.values(), key=sort_key, reverse=True)
        return sorted_vulns


def enhanced_vulnerability_scan(hosts):
    """
    Enhanced vulnerability scanning with improved data collection
    """
    vuln_scanner = MultiSourceVulnerabilityScanner()
    
    total_vulns_found = 0
    critical_vulns = 0
    high_vulns = 0
    
    for host in hosts:
        ip = host["ip"]
        print(f"\nScanning vulnerabilities for host: {ip}")
        print(f"{'='*60}")
        
        for svc in host["services"]:
            port = svc["port"]
            service = svc.get("service") or svc.get("product", "") or svc.get("name", "")
            version = svc.get("version", "")
            banner = svc.get("banner", "")
            
            if not service:
                print(f"  Port {port}: No service identified, skipping vulnerability scan")
                continue
            
            print(f"\n  Port {port} ({service} {version or 'version unknown'})")
            print(f"  {'─'*50}")
            
            # Scan vulnerabilities using multiple sources
            vuln_results = vuln_scanner.scan_vulnerabilities(
                service=service,
                version=version,
                port=port,
                banner=banner
            )
            
            # Add results to service
            svc["vulnerabilities"] = vuln_results["vulnerabilities"]
            svc["vuln_sources"] = vuln_results["sources_used"]
            svc["vuln_confidence"] = vuln_results["confidence"]
            svc["vuln_count"] = vuln_results["total_found"]
            svc["search_strategy"] = vuln_results["search_strategy"]
            
            total_vulns_found += vuln_results["total_found"]
            
            # Count severity levels
            for vuln in vuln_results["vulnerabilities"]:
                severity = vuln.get('severity', '')
                if severity == 'CRITICAL':
                    critical_vulns += 1
                elif severity == 'HIGH':
                    high_vulns += 1
            
            # Print detailed summary
            if vuln_results["total_found"] > 0:
                print(f"  Found {vuln_results['total_found']} vulnerabilities")
                print(f"  Sources: {', '.join(vuln_results['sources_used'])}")
                print(f"  Confidence: {vuln_results['confidence'].upper()}")
                print(f"  Strategy: {vuln_results['search_strategy']}")
                
                # Show top 3 vulnerabilities
                top_vulns = vuln_results["vulnerabilities"][:3]
                for i, vuln in enumerate(top_vulns, 1):
                    severity_indicator = {
                        'CRITICAL': '[CRIT]',
                        'HIGH': '[HIGH]',
                        'MEDIUM': '[MED]',
                        'LOW': '[LOW]',
                        'INFO': '[INFO]'
                    }.get(vuln.get('severity', 'INFO'), '[UNK]')
                    
                    print(f"    {severity_indicator} #{i}: {vuln['id']} (CVSS: {vuln.get('cvss_score', 'N/A')}) - {vuln.get('severity', 'UNKNOWN')}")
                    if vuln.get('exploited_in_wild'):
                        print(f"        ACTIVELY EXPLOITED IN THE WILD!")
                    
                    # Truncate long descriptions
                    desc = vuln.get('description', '')
                    if len(desc) > 100:
                        desc = desc[:100] + "..."
                    print(f"        {desc}")
            else:
                print(f"  No vulnerabilities found")
                
                # Suggest alternative searches if no results
                if version:
                    print(f"    Try searching without version for general {service} vulnerabilities")
    
    # Final summary
    print(f"\n{'='*60}")
    print(f"VULNERABILITY SCAN SUMMARY")
    print(f"{'='*60}")
    print(f"Total vulnerabilities found: {total_vulns_found}")
    print(f"Critical vulnerabilities: {critical_vulns}")
    print(f"High severity vulnerabilities: {high_vulns}")
    
    if critical_vulns > 0:
        print(f"URGENT: {critical_vulns} critical vulnerabilities require immediate attention!")
    elif high_vulns > 0:
        print(f"WARNING: {high_vulns} high severity vulnerabilities found")
    
    return hosts


# Utility function to test a single service
def test_vulnerability_scan(service: str, version: str = None):
    """
    Test vulnerability scanning for a single service
    """
    scanner = MultiSourceVulnerabilityScanner()
    
    print(f"Testing vulnerability scan for: {service} {version or '(no version)'}")
    print(f"{'='*60}")
    
    results = scanner.scan_vulnerabilities(service, version)
    
    print(f"\nRESULTS:")
    print(f"Total found: {results['total_found']}")
    print(f"Sources used: {', '.join(results['sources_used'])}")
    print(f"Confidence: {results['confidence']}")
    print(f"Search strategy: {results['search_strategy']}")
    
    if results['vulnerabilities']:
        print(f"\nTop vulnerabilities:")
        for i, vuln in enumerate(results['vulnerabilities'][:5], 1):
            severity_indicator = {
                'CRITICAL': '[CRIT]',
                'HIGH': '[HIGH]',
                'MEDIUM': '[MED]',
                'LOW': '[LOW]',
                'INFO': '[INFO]'
            }.get(vuln.get('severity', 'INFO'), '[UNK]')
            
            print(f"  {severity_indicator} {i}. {vuln['id']} - {vuln.get('severity', 'UNKNOWN')}")
            print(f"     CVSS: {vuln.get('cvss_score', 'N/A')} | Source: {vuln.get('source', 'Unknown')}")
            
            desc = vuln.get('description', 'No description available')
            if len(desc) > 120:
                desc = desc[:120] + "..."
            print(f"     {desc}")
            
            if vuln.get('exploited_in_wild'):
                print(f"     ACTIVELY EXPLOITED!")
            
            print()
    else:
        print(f"\nNo vulnerabilities found for {service}")
    
    return results


# Advanced vulnerability analysis functions
class VulnerabilityAnalyzer:
    """Additional analysis tools for vulnerability data"""
    
    @staticmethod
    def analyze_vulnerability_trends(hosts: List[Dict]) -> Dict[str, Any]:
        """Analyze vulnerability trends across all scanned hosts"""
        
        all_vulns = []
        service_vuln_count = {}
        severity_distribution = {'CRITICAL': 0, 'HIGH': 0, 'MEDIUM': 0, 'LOW': 0, 'INFO': 0}
        exploited_vulns = []
        
        for host in hosts:
            for service in host.get('services', []):
                service_name = service.get('service', 'unknown')
                vulns = service.get('vulnerabilities', [])
                
                all_vulns.extend(vulns)
                service_vuln_count[service_name] = service_vuln_count.get(service_name, 0) + len(vulns)
                
                for vuln in vulns:
                    severity = vuln.get('severity', 'INFO')
                    severity_distribution[severity] = severity_distribution.get(severity, 0) + 1
                    
                    if vuln.get('exploited_in_wild'):
                        exploited_vulns.append(vuln)
        
        # Find most vulnerable services
        most_vulnerable = sorted(service_vuln_count.items(), key=lambda x: x[1], reverse=True)
        
        # Calculate risk score
        risk_score = (
            severity_distribution['CRITICAL'] * 10 +
            severity_distribution['HIGH'] * 7 +
            severity_distribution['MEDIUM'] * 4 +
            severity_distribution['LOW'] * 1
        )
        
        return {
            'total_vulnerabilities': len(all_vulns),
            'severity_distribution': severity_distribution,
            'most_vulnerable_services': most_vulnerable[:5],
            'exploited_in_wild_count': len(exploited_vulns),
            'risk_score': risk_score,
            'exploited_vulnerabilities': exploited_vulns,
            'recommendations': VulnerabilityAnalyzer._generate_recommendations(
                severity_distribution, exploited_vulns, most_vulnerable
            )
        }
    
    @staticmethod
    def _generate_recommendations(severity_dist: Dict, exploited_vulns: List, vulnerable_services: List) -> List[str]:
        """Generate actionable recommendations based on vulnerability analysis"""
        
        recommendations = []
        
        if severity_dist.get('CRITICAL', 0) > 0:
            recommendations.append(
                f"IMMEDIATE ACTION: {severity_dist['CRITICAL']} critical vulnerabilities require urgent patching"
            )
        
        if exploited_vulns:
            recommendations.append(
                f"PRIORITY: {len(exploited_vulns)} vulnerabilities are being actively exploited in the wild"
            )
        
        if vulnerable_services:
            top_service = vulnerable_services[0]
            recommendations.append(
                f"Focus on {top_service[0]} - most vulnerable service with {top_service[1]} vulnerabilities"
            )
        
        if severity_dist.get('HIGH', 0) > 5:
            recommendations.append(
                "High number of HIGH severity vulnerabilities - implement a patching schedule"
            )
        
        total_vulns = sum(severity_dist.values())
        if total_vulns > 20:
            recommendations.append(
                "Consider implementing vulnerability management tools and automated scanning"
            )
        
        if not recommendations:
            recommendations.append("Good security posture - continue regular vulnerability assessments")
        
        return recommendations
    
    @staticmethod
    def export_vulnerability_report(hosts: List[Dict], filename: str = "vulnerability_report.json"):
        """Export detailed vulnerability report"""
        
        report_data = {
            'scan_timestamp': datetime.now().isoformat(),
            'summary': VulnerabilityAnalyzer.analyze_vulnerability_trends(hosts),
            'detailed_results': hosts
        }
        
        try:
            with open(filename, 'w') as f:
                json.dump(report_data, f, indent=2)
            print(f"Vulnerability report exported to: {filename}")
        except Exception as e:
            print(f"Failed to export report: {e}")
        
        return report_data


# Complete vulnerability assessment with analysis and reporting
def comprehensive_vulnerability_assessment(hosts):
    """
    Complete vulnerability assessment with analysis and reporting
    """
    print("Starting Comprehensive Vulnerability Assessment")
    print("=" * 70)
    
    # Enhanced vulnerability scanning
    scanned_hosts = enhanced_vulnerability_scan(hosts)
    
    # Analyze trends and generate insights
    analysis = VulnerabilityAnalyzer.analyze_vulnerability_trends(scanned_hosts)
    
    # Print analysis summary
    print(f"\nVULNERABILITY ANALYSIS SUMMARY")
    print("=" * 70)
    print(f"Total vulnerabilities: {analysis['total_vulnerabilities']}")
    print(f"Critical: {analysis['severity_distribution']['CRITICAL']}")
    print(f"High: {analysis['severity_distribution']['HIGH']}")
    print(f"Medium: {analysis['severity_distribution']['MEDIUM']}")
    print(f"Low: {analysis['severity_distribution']['LOW']}")
    print(f"Actively exploited: {analysis['exploited_in_wild_count']}")
    print(f"Risk Score: {analysis['risk_score']}")
    
    if analysis['most_vulnerable_services']:
        print(f"\nMost Vulnerable Services:")
        for service, count in analysis['most_vulnerable_services']:
            print(f"   • {service}: {count} vulnerabilities")
    
    print(f"\nRECOMMENDATIONS:")
    for rec in analysis['recommendations']:
        print(f"   • {rec}")
    
    # Export report
    VulnerabilityAnalyzer.export_vulnerability_report(scanned_hosts)
    
    return scanned_hosts, analysis