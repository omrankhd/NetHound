import requests
import time
from typing import Dict, List, Optional, Any
from concurrent.futures import ThreadPoolExecutor
import re
from datetime import datetime, timedelta
from urllib.parse import quote
import os

class MultiSourceVulnerabilityScanner:
    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'NetHound-Scanner/1.0'
        })
                
        # Rate limiting
        self.last_request_time = {}
        
        # Cache for CISA KEV data (loaded once)
        self.cisa_kev_cache = None
        self.cisa_kev_loaded = False
        
    def scan_vulnerabilities(self, service: str, version: str = None, port: int = None, 
                           banner: str = None) -> Dict[str, Any]:
       
        results = {
            'vulnerabilities': [],
            'sources_used': [],
            'confidence': 'medium',
            'total_found': 0,
            'search_strategy': 'version_specific' if version else 'service_generic'
        }
        
        print(f"Scanning {service} {version or '(no version)'}")
        
        
        sources = [
            ('NVD_NIST', self._query_nvd_nist),
            ('CVE_CircL', self._query_circl_cve),
            ('CISA_KEV', self._query_cisa_kev),
            ('VulDB_API', self._query_vuldb_api),  
            ('OSV_API', self._query_osv_api),
            ('SecurityVuln_API', self._query_securityvuln_api) 
        ]
        
        all_vulnerabilities = []
        
        # If no version, get recent vulnerabilities for the service
        if not version:
            print("No version specified - searching for recent vulnerabilities")
            results['search_strategy'] = 'recent_generic'
        
        with ThreadPoolExecutor(max_workers=3) as executor:
            futures = []
            
            for source_name, source_func in sources:
                try:
                    future = executor.submit(source_func, service, version, port, banner)
                    futures.append((source_name, future))
                except Exception as e:
                    print(f"Error submitting {source_name}: {e}")
            
            for source_name, future in futures:
                try:
                    source_result = future.result(timeout=15)
                    if source_result and source_result.get('vulnerabilities'):
                        all_vulnerabilities.extend(source_result['vulnerabilities'])
                        results['sources_used'].append(source_name)
                        print(f"{source_name}: {len(source_result['vulnerabilities'])} vulnerabilities")
                    else:
                        print(f"{source_name}: No vulnerabilities found")
                except Exception as e:
                    print(f"{source_name}: Error - {e}")
        
        
        results['vulnerabilities'] = self._deduplicate_vulnerabilities(all_vulnerabilities)
        results['total_found'] = len(results['vulnerabilities'])
        
        # If no version provided and we have results, limit to top 5 most recent
        if not version and results['vulnerabilities']:
            results['vulnerabilities'] = self._get_top_recent_vulnerabilities(
                results['vulnerabilities'], limit=5
            )
            results['total_found'] = len(results['vulnerabilities'])
            print(f"Limited to top {len(results['vulnerabilities'])} recent vulnerabilities")
        
        # Set confidence based on number of sources and data quality
        if len(results['sources_used']) >= 3:
            results['confidence'] = 'high'
        elif len(results['sources_used']) >= 2:
            results['confidence'] = 'medium'
        elif len(results['sources_used']) >= 1:
            results['confidence'] = 'low'
        else:
            results['confidence'] = 'none'
        
        return results
    
    def _rate_limit(self, source: str, min_interval: float = 1.0):
        """Improved rate limiting with backoff"""
        now = time.time()
        if source in self.last_request_time:
            time_passed = now - self.last_request_time[source]
            if time_passed < min_interval:
                sleep_time = min_interval - time_passed
                time.sleep(sleep_time)
        self.last_request_time[source] = time.time()
    
    def _query_nvd_nist(self, service: str, version: str = None, port: int = None, 
                       banner: str = None) -> Dict[str, Any]:
        """
        Query NIST NVD API 2.0 - Most reliable source
        Requires API key from https://nvd.nist.gov/developers/request-an-api-key
        """
        self._rate_limit('nvd', 2.0)  # NVD strict rate limits
        
        try:
            base_url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
            
            # Build search parameters
            params = {
                'resultsPerPage': 50 if version else 20,  # More results if no version
                'startIndex': 0
            }
            
            # Get API key from environment variable
            NVD_API_KEY = os.getenv('NVD_API_KEY')
            headers = {}
            if NVD_API_KEY:
                headers['apiKey'] = NVD_API_KEY
                print("  Using NVD API key")
            else:
                print("  No NVD API key configured, using public access (rate limited)")
                # Add longer delay for unauthenticated requests
                time.sleep(6)
            
            # Use keyword search strategy for both with and without version
            if version:
                # Search with both service name and version
                params['keywordSearch'] = f"{service.lower()} {version}"
                search_strategy = "version_specific"
            else:
                # Search for service only
                params['keywordSearch'] = service.lower()
                # Get recent vulnerabilities (last 2 years)
                two_years_ago = (datetime.now() - timedelta(days=730)).strftime('%Y-%m-%dT00:00:00.000')
                params['pubStartDate'] = two_years_ago
                search_strategy = "keyword_recent"
            
            print(f"  NVD strategy: {search_strategy}")
            response = self.session.get(base_url, params=params, headers=headers, timeout=15)
            
            if response.status_code in [403, 429]:
                wait_time = 10 if not NVD_API_KEY else 6
                print(f"  NVD rate limit hit, waiting {wait_time} seconds and retrying...")
                time.sleep(wait_time)
                response = self.session.get(base_url, params=params, headers=headers, timeout=15)
            
            if response.status_code == 401 and NVD_API_KEY:
                print("  NVD API key invalid or expired, falling back to public access")
                headers = {}
                time.sleep(6)  # Add delay for public access
                response = self.session.get(base_url, params=params, headers=headers, timeout=15)
            
            response.raise_for_status()
            data = response.json()
            vulnerabilities = []
            
            if 'vulnerabilities' in data:
                for vuln_item in data['vulnerabilities'][:20]:  # Limit results
                    cve = vuln_item.get('cve', {})
                    
                    # Extract CVSS score with fallback
                    cvss_score = 0.0
                    cvss_vector = ""
                    
                    metrics = cve.get('metrics', {})
                    if 'cvssMetricV31' in metrics and metrics['cvssMetricV31']:
                        cvss_data = metrics['cvssMetricV31'][0]['cvssData']
                        cvss_score = cvss_data.get('baseScore', 0.0)
                        cvss_vector = cvss_data.get('vectorString', '')
                    elif 'cvssMetricV30' in metrics and metrics['cvssMetricV30']:
                        cvss_data = metrics['cvssMetricV30'][0]['cvssData']
                        cvss_score = cvss_data.get('baseScore', 0.0)
                        cvss_vector = cvss_data.get('vectorString', '')
                    elif 'cvssMetricV2' in metrics and metrics['cvssMetricV2']:
                        cvss_data = metrics['cvssMetricV2'][0]['cvssData']
                        cvss_score = cvss_data.get('baseScore', 0.0)
                        cvss_vector = cvss_data.get('vectorString', '')
                    
                    # Get description
                    descriptions = cve.get('descriptions', [])
                    description = ""
                    for desc in descriptions:
                        if desc.get('lang') == 'en':
                            description = desc.get('value', '')
                            break
                    
                    vuln = {
                        'id': cve.get('id', ''),
                        'description': description,
                        'cvss_score': cvss_score,
                        'cvss_vector': cvss_vector,
                        'published_date': cve.get('published', ''),
                        'modified_date': cve.get('lastModified', ''),
                        'source': 'NIST_NVD',
                        'references': [ref.get('url', '') for ref in cve.get('references', [])],
                        'severity': self._get_severity_from_cvss(cvss_score),
                        'search_strategy': search_strategy
                    }
                    
                    vulnerabilities.append(vuln)
            
            print(f"  NVD returned {len(vulnerabilities)} vulnerabilities")
            return {'vulnerabilities': vulnerabilities}
            
        except Exception as e:
            print(f"NVD query error: {e}")
            return {'vulnerabilities': []}
    
    def _query_circl_cve(self, service: str, version: str = None, port: int = None, 
                        banner: str = None) -> Dict[str, Any]:
        """
        Query CIRCL CVE Search API - Good alternative to NVD
        """
        self._rate_limit('circl', 1.0)
        
        try:
            base_url = "https://cve.circl.lu/api"
            vulnerabilities = []
            
            if version:
                # Search by specific version
                search_url = f"{base_url}/search/{service}/{version}"
            else:
                # Browse recent CVEs for service
                search_url = f"{base_url}/browse/{service.lower()}"
            
            response = self.session.get(search_url, timeout=10)
            
            if response.status_code == 200:
                data = response.json()
                
                # Handle different response formats
                if isinstance(data, list):
                    cve_list = data
                elif isinstance(data, dict) and 'results' in data:
                    cve_list = data['results']
                else:
                    cve_list = [data] if data else []
                
                for cve_item in cve_list[:15]:  # Limit results
                    if isinstance(cve_item, str):
                        # If we just get CVE IDs, fetch details
                        cve_id = cve_item
                        cve_detail_url = f"{base_url}/cve/{cve_id}"
                        detail_response = self.session.get(cve_detail_url, timeout=5)
                        if detail_response.status_code == 200:
                            cve_data = detail_response.json()
                        else:
                            continue
                    else:
                        cve_data = cve_item
                    
                    # Extract vulnerability info
                    vuln = {
                        'id': cve_data.get('id', ''),
                        'description': cve_data.get('summary', ''),
                        'cvss_score': float(cve_data.get('cvss', 0)) if cve_data.get('cvss') else 0.0,
                        'published_date': cve_data.get('Published', ''),
                        'modified_date': cve_data.get('Modified', ''),
                        'source': 'CIRCL_CVE',
                        'references': cve_data.get('references', []),
                        'severity': self._get_severity_from_cvss(float(cve_data.get('cvss', 0)) if cve_data.get('cvss') else 0.0)
                    }
                    
                    vulnerabilities.append(vuln)
                    time.sleep(0.2)  # Small delay between detail requests
            
            print(f"  CIRCL returned {len(vulnerabilities)} vulnerabilities")
            return {'vulnerabilities': vulnerabilities}
            
        except Exception as e:
            print(f"CIRCL query error: {e}")
            return {'vulnerabilities': []}
    
    def _query_osv_api(self, service: str, version: str = None, port: int = None, 
                      banner: str = None) -> Dict[str, Any]:
        """
        Query Google's OSV (Open Source Vulnerabilities) API
        """
        self._rate_limit('osv', 0.5)
        
        try:
            url = "https://api.osv.dev/v1/query"
            
            # OSV query format
            if version:
                query_data = {
                    "package": {
                        "name": service.lower()
                    },
                    "version": version
                }
            else:
                # For no version, use broader ecosystem search
                query_data = {
                    "package": {
                        "name": service.lower()
                    }
                }
            
            response = self.session.post(url, json=query_data, timeout=10)
            
            if response.status_code != 200:
                return {'vulnerabilities': []}
            
            data = response.json()
            vulnerabilities = []
            
            if 'vulns' in data:
                for vuln_item in data['vulns'][:15]:  # Limit results
                    # Extract severity info
                    severity_info = vuln_item.get('severity', [])
                    cvss_score = 0.0
                    
                    for sev in severity_info:
                        if sev.get('type') == 'CVSS_V3':
                            cvss_score = float(sev.get('score', 0))
                            break
                        elif sev.get('type') == 'CVSS_V2':
                            cvss_score = float(sev.get('score', 0))
                    
                    vuln = {
                        'id': vuln_item.get('id', ''),
                        'description': vuln_item.get('summary', ''),
                        'cvss_score': cvss_score,
                        'published_date': vuln_item.get('published', ''),
                        'modified_date': vuln_item.get('modified', ''),
                        'source': 'OSV_Google',
                        'references': [ref.get('url', '') for ref in vuln_item.get('references', [])],
                        'severity': self._get_severity_from_cvss(cvss_score),
                        'affected_versions': [affected.get('versions', []) for affected in vuln_item.get('affected', [])]
                    }
                    
                    vulnerabilities.append(vuln)
            
            print(f"  OSV returned {len(vulnerabilities)} vulnerabilities")
            return {'vulnerabilities': vulnerabilities}
            
        except Exception as e:
            print(f"OSV query error: {e}")
            return {'vulnerabilities': []}
    
    
    
    def _query_vuldb_api(self, service: str, version: str = None, port: int = None, 
                        banner: str = None) -> Dict[str, Any]:
        """
        Query VulDB API - https://vuldb.com/
        Fixed version with correct API endpoint and request format
        """
        self._rate_limit('vuldb', 1.0)
        
        VULDB_API_KEY = os.getenv('VULDB_API_KEY')
        print(VULDB_API_KEY)
        if not VULDB_API_KEY:
            print("  VulDB API key not configured, skipping source")
            return {'vulnerabilities': []}
        
        try:
            # Correct API endpoint - remove the ?api query parameter
            api_url = "https://vuldb.com/"
            
            # Build search query - combine service and version
            search_query = service.lower()
            if version and version != "Unknown":
                search_query += f" {version}"
            
            # Correct request format - use form data, not JSON
            query_data = {
                'apikey': VULDB_API_KEY,
                'search': search_query,
                'details': '1',  # String value, not integer
                'limit': '3'    # Limit to 3 most recent results
            }
            
            # Simplified headers - remove redundant API key header
            headers = {
                'Accept': 'application/json',
                'User-Agent': 'VulnerabilityScanner/1.0'
            }
            
            print(f"Request details:\nURL: {api_url}\nHeaders: {headers}\nData: {query_data}")
            
            # Use POST with form data (data parameter), not JSON
            response = self.session.post(api_url, data=query_data, headers=headers, timeout=15)
            print(f"Response Status: {response.status_code}")
            print(f"Response Content: {response.text[:500]}...")  # First 500 chars for debugging
            
            response.raise_for_status()
            
            data = response.json()
            print(f"Parsed JSON: {data}")
            vulnerabilities = []
            
            # Handle different response formats
            if 'result' in data and data['result']:
                entries = data['result']
                if isinstance(entries, list):
                    for entry in entries[:3]:  # Limit to 3 results (fallback if API doesn't respect 'recent' parameter)
                        vuln = self._parse_vuldb_entry(entry)
                        if vuln:
                            vulnerabilities.append(vuln)
                else:
                    # Single entry response
                    vuln = self._parse_vuldb_entry(entries)
                    if vuln:
                        vulnerabilities.append(vuln)
            elif 'response' in data:
                # Alternative response format
                for entry in data.get('response', [])[:3]:
                    vuln = self._parse_vuldb_entry(entry)
                    if vuln:
                        vulnerabilities.append(vuln)
            else:
                print(f"Unexpected response format: {list(data.keys())}")
            
            print(f"  VulDB returned {len(vulnerabilities)} vulnerabilities")
            return {'vulnerabilities': vulnerabilities}
            
        except requests.exceptions.RequestException as e:
            print(f"VulDB request error: {e}")
            if hasattr(e, 'response') and e.response is not None:
                print(f"Response status: {e.response.status_code}")
                print(f"Response content: {e.response.text[:200]}")
            return {'vulnerabilities': []}
        except ValueError as e:
            print(f"VulDB JSON parsing error: {e}")
            return {'vulnerabilities': []}
        except Exception as e:
            print(f"VulDB query error: {e}")
            return {'vulnerabilities': []}

    def _parse_vuldb_entry(self, entry: dict) -> dict:
        """
        Parse a VulDB entry into standardized vulnerability format
        """
        try:
            # Handle different entry structures
            if 'entry' in entry:
                entry_data = entry['entry']
                vuln_data = entry.get('vulnerability', {})
            else:
                entry_data = entry
                vuln_data = entry.get('vulnerability', {})
            
            # Extract CVSS score
            cvss_score = 0.0
            if 'cvss' in vuln_data:
                cvss_info = vuln_data['cvss']
                if isinstance(cvss_info, dict):
                    cvss_score = float(cvss_info.get('score', 0.0))
                else:
                    try:
                        cvss_score = float(cvss_info)
                    except (ValueError, TypeError):
                        cvss_score = 0.0
            
            # Extract basic information
            vuln_id = entry_data.get('id', '')
            title = entry_data.get('title', '')
            published = entry_data.get('created', entry_data.get('published', ''))
            modified = entry_data.get('modified', published)
            
            # Build vulnerability object
            vuln = {
                'id': str(vuln_id),
                'description': title,
                'cvss_score': cvss_score,
                'published_date': published,
                'modified_date': modified,
                'source': 'VulDB',
                'references': self._extract_vuldb_references(entry),
                'severity': self._get_severity_from_cvss(cvss_score),
                'vuldb_id': str(vuln_id),
                'risk': vuln_data.get('risk', {}).get('name', 'Unknown') if isinstance(vuln_data.get('risk'), dict) else str(vuln_data.get('risk', 'Unknown'))
            }
            
            return vuln
            
        except Exception as e:
            print(f"Error parsing VulDB entry: {e}")
            return None
    def _extract_vuldb_references(self, entry: Dict) -> List[str]:
        """Helper method to extract references from VulDB entry"""
        references = []
        
        if 'source' in entry and 'list' in entry['source']:
            for source in entry['source']['list']:
                if 'url' in source:
                    references.append(source['url'])
        
        if 'entry' in entry and 'references' in entry['entry']:
            for ref in entry['entry']['references']:
                if isinstance(ref, dict) and 'url' in ref:
                    references.append(ref['url'])
        
        return list(set(references))
    
    def _query_cisa_kev(self, service: str, version: str = None, port: int = None, 
                       banner: str = None) -> Dict[str, Any]:
        """
        Query CISA Known Exploited Vulnerabilities - Critical ones only
        """
        if not self.cisa_kev_loaded:
            self._load_cisa_kev_data()
        
        try:
            vulnerabilities = []
            
            if not self.cisa_kev_cache:
                return {'vulnerabilities': vulnerabilities}
            
            service_lower = service.lower() if service else ""
            version_lower = version.lower() if version else ""
            
            for kev_item in self.cisa_kev_cache:
                # Improved matching logic
                vuln_name = kev_item.get('vulnerabilityName', '').lower()
                product = kev_item.get('product', '').lower()
                vendor = kev_item.get('vendorProject', '').lower()
                
                # Check if this KEV relates to our service
                matches = (
                    service_lower in vuln_name or 
                    service_lower in product or 
                    service_lower in vendor or
                    any(service_lower in word for word in vuln_name.split()) or
                    any(service_lower in word for word in product.split())
                )
                
                if matches:
                    # If version specified, try to match it too
                    version_matches = True
                    if version:
                        version_matches = (
                            version_lower in vuln_name or
                            version_lower in product or
                            any(version_lower in word for word in vuln_name.split())
                        )
                    
                    if version_matches:
                        vuln = {
                            'id': kev_item.get('cveID', ''),
                            'description': kev_item.get('vulnerabilityName', ''),
                            'cvss_score': 9.5,  # KEV items are high priority by definition
                            'published_date': kev_item.get('dateAdded', ''),
                            'due_date': kev_item.get('dueDate', ''),
                            'source': 'CISA_KEV',
                            'exploited_in_wild': True,
                            'severity': 'CRITICAL',
                            'required_action': kev_item.get('requiredAction', ''),
                            'product': product,
                            'vendor': vendor
                        }
                        vulnerabilities.append(vuln)
            
            print(f"  CISA KEV returned {len(vulnerabilities)} vulnerabilities")
            return {'vulnerabilities': vulnerabilities}
            
        except Exception as e:
            print(f"CISA KEV error: {e}")
            return {'vulnerabilities': []}
    
    def _query_securityvuln_api(self, service: str, version: str = None, port: int = None, 
                               banner: str = None) -> Dict[str, Any]:
        """
        Query json.securityvulnerability.io API - Additional source from testvuln.py
        """
        self._rate_limit('securityvuln', 1.0)
        
        try:
            base_url = "https://json.securityvulnerability.io/search"
            
            # Construct query string
            if version:
                if version =="Unknown":
                    query = service
                else:

                    query = f"{service} {version}"
            else:
                query = service
                
            # Use quote to encode special characters but preserve spaces
            encoded_query = quote(query, safe=' ')
            url = f"{base_url}?query={encoded_query}"
            
            response = self.session.get(url, timeout=15)
            response.raise_for_status()
            
            # Parse JSON response
            data = response.json()
            vulnerabilities = []
            
            # Filter and process the results using helper methods from testvuln.py
            filtered_data = self._filter_securityvuln_data(data, service, version, 20)
            
            if filtered_data.get('cves'):
                for cve_item in filtered_data['cves']:
                    vuln = {
                        'id': cve_item.get('id', ''),
                        'description': cve_item.get('description', ''),
                        'cvss_score': cve_item.get('cvss_score', 0.0),
                        'published_date': cve_item.get('published_date', ''),
                        'modified_date': cve_item.get('modified_date', ''),
                        'source': 'SecurityVuln_API',
                        'references': cve_item.get('references', []),
                        'severity': cve_item.get('severity', 'UNKNOWN')
                    }
                    vulnerabilities.append(vuln)
            
            print(f"  SecurityVuln returned {len(vulnerabilities)} vulnerabilities")
            return {'vulnerabilities': vulnerabilities}
            
        except Exception as e:
            print(f"SecurityVuln query error: {e}")
            return {'vulnerabilities': []}
    
    def _filter_securityvuln_data(self, raw_data: Any, service_name: str, version: str, max_results: int) -> Dict[str, Any]:
        """
        Filter and structure the CVE data from the SecurityVuln API response
        Enhanced from testvuln.py
        """
        filtered_result = {
            "service": service_name,
            "version": version,
            "total_found": 0,
            "cves": []
        }
        
        # Handle different response formats
        cve_list = []
        
        if isinstance(raw_data, dict):
            # Check common keys where CVEs might be stored
            for key in ['cves', 'vulnerabilities', 'results', 'data', 'items']:
                if key in raw_data and isinstance(raw_data[key], list):
                    cve_list = raw_data[key]
                    break
            
            # If no list found, check if the entire dict represents a single CVE
            if not cve_list and any(k.upper().startswith('CVE') for k in raw_data.keys()):
                cve_list = [raw_data]
                
        elif isinstance(raw_data, list):
            cve_list = raw_data
        
        # Process each CVE entry
        processed_cves = []
        for idx, cve_item in enumerate(cve_list[:max_results]):
            if isinstance(cve_item, dict):
                processed_cve = self._extract_securityvuln_cve_info(cve_item)
                if processed_cve:
                    processed_cves.append(processed_cve)
        
        filtered_result["cves"] = processed_cves
        filtered_result["total_found"] = len(processed_cves)
        
        return filtered_result
    
    def _extract_securityvuln_cve_info(self, cve_item: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """
        Extract standardized CVE information from a single CVE entry
        Enhanced from testvuln.py
        """
        # Common field mappings for different API response formats
        field_mappings = {
            'id': ['id', 'cve', 'cve_id', 'CVE', 'identifier'],
            'description': ['description', 'summary', 'desc', 'details'],
            'cvss_score': ['cvss', 'cvss_score', 'score', 'severity_score'],
            'severity': ['severity', 'level', 'criticality'],
            'published': ['published', 'publication_date', 'date', 'published_date'],
            'modified': ['modified', 'last_modified', 'updated', 'modification_date'],
            'references': ['references', 'refs', 'links', 'urls']
        }
        
        extracted_info = {}
        
        # Extract fields using mapping
        for standard_key, possible_keys in field_mappings.items():
            for key in possible_keys:
                if key in cve_item:
                    extracted_info[standard_key] = cve_item[key]
                    break
        
        # Only return if we found at least an ID or description
        if extracted_info.get('id') or extracted_info.get('description'):
            # Ensure we have basic structure
            result = {
                'id': extracted_info.get('id', 'Unknown'),
                'description': extracted_info.get('description', 'No description available'),
                'cvss_score': self._normalize_cvss_score(extracted_info.get('cvss_score')),
                'severity': self._normalize_severity(extracted_info.get('severity')),
                'published_date': extracted_info.get('published', 'Unknown'),
                'modified_date': extracted_info.get('modified', 'Unknown'),
                'references': self._normalize_references(extracted_info.get('references', []))
            }
            return result
        
        return None
    
    def _normalize_cvss_score(self, score: Any) -> float:
        """Normalize CVSS score to float - from testvuln.py"""
        if score is None:
            return 0.0
        try:
            if isinstance(score, (int, float)):
                return float(score)
            elif isinstance(score, str):
                # Extract numeric value from string
                match = re.search(r'(\d+\.?\d*)', score)
                if match:
                    return float(match.group(1))
            return 0.0
        except:
            return 0.0
    
    def _normalize_severity(self, severity: Any) -> str:
        """Normalize severity to standard levels - from testvuln.py"""
        if not severity:
            return "UNKNOWN"
        
        severity_str = str(severity).upper()
        
        # Map various severity formats to standard levels
        if any(word in severity_str for word in ['CRITICAL', 'CRIT']):
            return "CRITICAL"
        elif any(word in severity_str for word in ['HIGH', 'SEVERE']):
            return "HIGH"
        elif any(word in severity_str for word in ['MEDIUM', 'MED', 'MODERATE']):
            return "MEDIUM"
        elif any(word in severity_str for word in ['LOW', 'MINOR']):
            return "LOW"
        elif any(word in severity_str for word in ['INFO', 'INFORMATIONAL']):
            return "INFO"
        else:
            return severity_str
    
    def _normalize_references(self, references: Any) -> List[str]:
        """Normalize references to list of URLs - from testvuln.py"""
        if not references:
            return []
        
        if isinstance(references, str):
            return [references]
        elif isinstance(references, list):
            ref_list = []
            for ref in references:
                if isinstance(ref, str):
                    ref_list.append(ref)
                elif isinstance(ref, dict) and 'url' in ref:
                    ref_list.append(ref['url'])
            return ref_list
        
        return []
    
    def _load_cisa_kev_data(self):
        """Load CISA KEV data once and cache it"""
        try:
            self._rate_limit('cisa_kev_load', 2.0)
            url = "https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json"
            response = self.session.get(url, timeout=15)
            response.raise_for_status()
            
            data = response.json()
            self.cisa_kev_cache = data.get('vulnerabilities', [])
            self.cisa_kev_loaded = True
            print(f"  Loaded {len(self.cisa_kev_cache)} CISA KEV entries")
            
        except Exception as e:
            print(f"Failed to load CISA KEV data: {e}")
            self.cisa_kev_cache = []
            self.cisa_kev_loaded = True
    
    def _get_top_recent_vulnerabilities(self, vulnerabilities: List[Dict], limit: int = 5) -> List[Dict]:
        """
        Get top N most recent vulnerabilities when version is not available
        """
        # Sort by published date (most recent first) and CVSS score
        def sort_key(vuln):
            pub_date = vuln.get('published_date', '')
            cvss = vuln.get('cvss_score', 0)
            
            # Parse date for sorting
            try:
                if pub_date:
                    # Handle different date formats
                    for fmt in ['%Y-%m-%dT%H:%M:%S.%fZ', '%Y-%m-%dT%H:%M:%SZ', '%Y-%m-%d']:
                        try:
                            parsed_date = datetime.strptime(pub_date.split('T')[0], '%Y-%m-%d')
                            return (parsed_date, cvss)
                        except:
                            continue
                return (datetime.min, cvss)
            except:
                return (datetime.min, cvss)
        
        sorted_vulns = sorted(vulnerabilities, key=sort_key, reverse=True)
        return sorted_vulns[:limit]
    
    def _get_severity_from_cvss(self, cvss_score: float) -> str:
        """Convert CVSS score to severity level (CVSS v3.1 standard)"""
        if cvss_score >= 9.0:
            return "CRITICAL"
        elif cvss_score >= 7.0:
            return "HIGH"
        elif cvss_score >= 4.0:
            return "MEDIUM"
        elif cvss_score > 0.0:
            return "LOW"
        else:
            return "INFO"
    
    def _deduplicate_vulnerabilities(self, vulnerabilities: List[Dict]) -> List[Dict]:
        
        seen_cves = {}
        
        for vuln in vulnerabilities:
            cve_id = vuln.get('id', '')
            if not cve_id:
                continue
                
            if cve_id not in seen_cves:
                seen_cves[cve_id] = vuln
            else:
                # Merge information from multiple sources
                existing = seen_cves[cve_id]
                
                # Keep the one with higher CVSS score
                if vuln.get('cvss_score', 0) > existing.get('cvss_score', 0):
                    seen_cves[cve_id] = vuln
                
                # Merge references
                existing_refs = set(existing.get('references', []))
                new_refs = set(vuln.get('references', []))
                merged_refs = list(existing_refs.union(new_refs))
                seen_cves[cve_id]['references'] = merged_refs
                
                # Keep the longer description
                if len(str(vuln.get('description', ''))) > len(str(existing.get('description', ''))):
                    seen_cves[cve_id]['description'] = vuln.get('description', '')
        
        # Sort by CVSS score (highest first), then by date
        def sort_key(vuln):
            cvss = vuln.get('cvss_score', 0)
            pub_date = vuln.get('published_date', '')
            
            # Parse date for sorting
            try:
                if pub_date:
                    parsed_date = datetime.strptime(pub_date.split('T')[0], '%Y-%m-%d')
                    return (cvss, parsed_date)
            except:
                pass
            
            return (cvss, datetime.min)
        
        sorted_vulns = sorted(seen_cves.values(), key=sort_key, reverse=True)
        return sorted_vulns

# Utility function to test a single service
def test_vulnerability_scan(service: str, version: str = None):
    """
    Test vulnerability scanning for a single service
    """
    scanner = MultiSourceVulnerabilityScanner()
    
    print(f"Testing vulnerability scan for: {service} {version or '(no version)'}")
    print(f"{'='*60}")
    
    results = scanner.scan_vulnerabilities(service, version)
    
    print(f"\nRESULTS:")
    print(f"Total found: {results['total_found']}")
    print(f"Sources used: {', '.join(results['sources_used'])}")
    print(f"Confidence: {results['confidence']}")
    print(f"Search strategy: {results['search_strategy']}")
    
    if results['vulnerabilities']:
        print(f"\nTop vulnerabilities:")
        for i, vuln in enumerate(results['vulnerabilities'][:20], 1):
            severity_indicator = {
                'CRITICAL': '[CRIT]',
                'HIGH': '[HIGH]',
                'MEDIUM': '[MED]',
                'LOW': '[LOW]',
                'INFO': '[INFO]'
            }.get(vuln.get('severity', 'INFO'), '[UNK]')
            
            print(f"  {severity_indicator} {i}. {vuln['id']} - {vuln.get('severity', 'UNKNOWN')}")
            print(f"     CVSS: {vuln.get('cvss_score', 'N/A')} | Source: {vuln.get('source', 'Unknown')}")
            
            desc = vuln.get('description', 'No description available')
            if len(desc) > 120:
                desc = desc[:120] + "..."
            print(f"     {desc}")
            
            if vuln.get('exploited_in_wild'):
                print(f"     ACTIVELY EXPLOITED!")
            
            print()
    else:
        print(f"\nNo vulnerabilities found for {service}")
    
    return results


if __name__ == "__main__":
    # Example usage of test_vulnerability_scan
    service = "XG Firewall"
    version = "Unknown"
    print(f"\nTesting vulnerability scanner with:\nService: {service}\nVersion: {version}\n")
    test_vulnerability_scan(service, version)
