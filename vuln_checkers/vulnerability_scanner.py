import requests
import json
import time
from typing import Dict, List, Optional, Any
from concurrent.futures import ThreadPoolExecutor
import re
from datetime import datetime, timedelta
import csv
from io import StringIO

class MultiSourceVulnerabilityScanner:
    def __init__(self, shodan_api_key: str = None):
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        })
        
        # API keys (optional but recommended)
        self.shodan_api_key = shodan_api_key
        
        # Rate limiting
        self.last_request_time = {}
        
        # Cache for CISA KEV data (loaded once)
        self.cisa_kev_cache = None
        self.cisa_kev_loaded = False
        
    def scan_vulnerabilities(self, service: str, version: str = None, port: int = None, 
                           banner: str = None) -> Dict[str, Any]:
        """
        Multi-source vulnerability scanning with improved reliability
        """
        results = {
            'vulnerabilities': [],
            'sources_used': [],
            'confidence': 'medium',
            'total_found': 0,
            'search_strategy': 'version_specific' if version else 'service_generic'
        }
        
        print(f"ğŸ” Scanning {service} {version or '(no version)'}")
        
        # Use multiple sources with improved error handling
        sources = [
            ('NVD_NIST', self._query_nvd_nist),
            ('CVE_CircL', self._query_circl_cve),
            ('CISA_KEV', self._query_cisa_kev),
            ('VulnDB_API', self._query_vulndb_api),
            ('OSV_API', self._query_osv_api)
        ]
        
        all_vulnerabilities = []
        
        # If no version, get recent vulnerabilities for the service
        if not version:
            print("âš ï¸  No version specified - searching for recent vulnerabilities")
            results['search_strategy'] = 'recent_generic'
        
        with ThreadPoolExecutor(max_workers=3) as executor:
            futures = []
            
            for source_name, source_func in sources:
                try:
                    future = executor.submit(source_func, service, version, port, banner)
                    futures.append((source_name, future))
                except Exception as e:
                    print(f"âŒ Error submitting {source_name}: {e}")
            
            for source_name, future in futures:
                try:
                    source_result = future.result(timeout=15)
                    if source_result and source_result.get('vulnerabilities'):
                        all_vulnerabilities.extend(source_result['vulnerabilities'])
                        results['sources_used'].append(source_name)
                        print(f"âœ… {source_name}: {len(source_result['vulnerabilities'])} vulnerabilities")
                    else:
                        print(f"â„¹ï¸  {source_name}: No vulnerabilities found")
                except Exception as e:
                    print(f"âŒ {source_name}: Error - {e}")
        
        # Deduplicate and sort
        results['vulnerabilities'] = self._deduplicate_vulnerabilities(all_vulnerabilities)
        results['total_found'] = len(results['vulnerabilities'])
        
        # If no version provided and we have results, limit to top 5 most recent
        if not version and results['vulnerabilities']:
            results['vulnerabilities'] = self._get_top_recent_vulnerabilities(
                results['vulnerabilities'], limit=5
            )
            results['total_found'] = len(results['vulnerabilities'])
            print(f"ğŸ“Œ Limited to top {len(results['vulnerabilities'])} recent vulnerabilities")
        
        # Set confidence based on number of sources and data quality
        if len(results['sources_used']) >= 3:
            results['confidence'] = 'high'
        elif len(results['sources_used']) >= 2:
            results['confidence'] = 'medium'
        elif len(results['sources_used']) >= 1:
            results['confidence'] = 'low'
        else:
            results['confidence'] = 'none'
        
        return results
    
    def _rate_limit(self, source: str, min_interval: float = 1.0):
        """Improved rate limiting with backoff"""
        now = time.time()
        if source in self.last_request_time:
            time_passed = now - self.last_request_time[source]
            if time_passed < min_interval:
                sleep_time = min_interval - time_passed
                time.sleep(sleep_time)
        self.last_request_time[source] = time.time()
    
    def _query_nvd_nist(self, service: str, version: str = None, port: int = None, 
                       banner: str = None) -> Dict[str, Any]:
        """
        Query NIST NVD API 2.0 - Most reliable source
        """
        self._rate_limit('nvd', 2.0)  # NVD strict rate limits
        
        try:
            base_url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
            
            # Build search parameters
            params = {
                'resultsPerPage': 50 if version else 20,  # More results if no version
                'startIndex': 0
            }
            
            # Strategy 1: If we have version, search specifically
            if version:
                # Try CPE format first
                cpe_name = f"cpe:2.3:a:*:{service.lower()}:{version}:*:*:*:*:*:*:*"
                params['cpeName'] = cpe_name
                search_strategy = "cpe_specific"
            else:
                # Strategy 2: Keyword search for service only
                params['keywordSearch'] = service.lower()
                # Get recent vulnerabilities (last 2 years)
                two_years_ago = (datetime.now() - timedelta(days=730)).strftime('%Y-%m-%dT00:00:00.000')
                params['pubStartDate'] = two_years_ago
                search_strategy = "keyword_recent"
            
            print(f"  ğŸ” NVD strategy: {search_strategy}")
            response = self.session.get(base_url, params=params, timeout=15)
            
            if response.status_code == 403:
                print("  âš ï¸  NVD rate limit hit, trying fallback search")
                # Fallback to basic keyword search
                params = {
                    'keywordSearch': service.lower(),
                    'resultsPerPage': 20
                }
                time.sleep(3)
                response = self.session.get(base_url, params=params, timeout=15)
            
            response.raise_for_status()
            data = response.json()
            vulnerabilities = []
            
            if 'vulnerabilities' in data:
                for vuln_item in data['vulnerabilities'][:20]:  # Limit results
                    cve = vuln_item.get('cve', {})
                    
                    # Extract CVSS score with fallback
                    cvss_score = 0.0
                    cvss_vector = ""
                    
                    metrics = cve.get('metrics', {})
                    if 'cvssMetricV31' in metrics and metrics['cvssMetricV31']:
                        cvss_data = metrics['cvssMetricV31'][0]['cvssData']
                        cvss_score = cvss_data.get('baseScore', 0.0)
                        cvss_vector = cvss_data.get('vectorString', '')
                    elif 'cvssMetricV30' in metrics and metrics['cvssMetricV30']:
                        cvss_data = metrics['cvssMetricV30'][0]['cvssData']
                        cvss_score = cvss_data.get('baseScore', 0.0)
                        cvss_vector = cvss_data.get('vectorString', '')
                    elif 'cvssMetricV2' in metrics and metrics['cvssMetricV2']:
                        cvss_data = metrics['cvssMetricV2'][0]['cvssData']
                        cvss_score = cvss_data.get('baseScore', 0.0)
                        cvss_vector = cvss_data.get('vectorString', '')
                    
                    # Get description
                    descriptions = cve.get('descriptions', [])
                    description = ""
                    for desc in descriptions:
                        if desc.get('lang') == 'en':
                            description = desc.get('value', '')
                            break
                    
                    vuln = {
                        'id': cve.get('id', ''),
                        'description': description,
                        'cvss_score': cvss_score,
                        'cvss_vector': cvss_vector,
                        'published_date': cve.get('published', ''),
                        'modified_date': cve.get('lastModified', ''),
                        'source': 'NIST_NVD',
                        'references': [ref.get('url', '') for ref in cve.get('references', [])],
                        'severity': self._get_severity_from_cvss(cvss_score),
                        'search_strategy': search_strategy
                    }
                    
                    vulnerabilities.append(vuln)
            
            print(f"  ğŸ“Š NVD returned {len(vulnerabilities)} vulnerabilities")
            return {'vulnerabilities': vulnerabilities}
            
        except Exception as e:
            print(f"âŒ NVD query error: {e}")
            return {'vulnerabilities': []}
    
    def _query_circl_cve(self, service: str, version: str = None, port: int = None, 
                        banner: str = None) -> Dict[str, Any]:
        """
        Query CIRCL CVE Search API - Good alternative to NVD
        """
        self._rate_limit('circl', 1.0)
        
        try:
            base_url = "https://cve.circl.lu/api"
            vulnerabilities = []
            
            if version:
                # Search by specific version
                search_url = f"{base_url}/search/{service}/{version}"
            else:
                # Browse recent CVEs for service
                search_url = f"{base_url}/browse/{service.lower()}"
            
            response = self.session.get(search_url, timeout=10)
            
            if response.status_code == 200:
                data = response.json()
                
                # Handle different response formats
                if isinstance(data, list):
                    cve_list = data
                elif isinstance(data, dict) and 'results' in data:
                    cve_list = data['results']
                else:
                    cve_list = [data] if data else []
                
                for cve_item in cve_list[:15]:  # Limit results
                    if isinstance(cve_item, str):
                        # If we just get CVE IDs, fetch details
                        cve_id = cve_item
                        cve_detail_url = f"{base_url}/cve/{cve_id}"
                        detail_response = self.session.get(cve_detail_url, timeout=5)
                        if detail_response.status_code == 200:
                            cve_data = detail_response.json()
                        else:
                            continue
                    else:
                        cve_data = cve_item
                    
                    # Extract vulnerability info
                    vuln = {
                        'id': cve_data.get('id', ''),
                        'description': cve_data.get('summary', ''),
                        'cvss_score': float(cve_data.get('cvss', 0)) if cve_data.get('cvss') else 0.0,
                        'published_date': cve_data.get('Published', ''),
                        'modified_date': cve_data.get('Modified', ''),
                        'source': 'CIRCL_CVE',
                        'references': cve_data.get('references', []),
                        'severity': self._get_severity_from_cvss(float(cve_data.get('cvss', 0)) if cve_data.get('cvss') else 0.0)
                    }
                    
                    vulnerabilities.append(vuln)
                    time.sleep(0.2)  # Small delay between detail requests
            
            print(f"  ğŸ“Š CIRCL returned {len(vulnerabilities)} vulnerabilities")
            return {'vulnerabilities': vulnerabilities}
            
        except Exception as e:
            print(f"âŒ CIRCL query error: {e}")
            return {'vulnerabilities': []}
    
    def _query_osv_api(self, service: str, version: str = None, port: int = None, 
                      banner: str = None) -> Dict[str, Any]:
        """
        Query Google's OSV (Open Source Vulnerabilities) API
        """
        self._rate_limit('osv', 0.5)
        
        try:
            url = "https://api.osv.dev/v1/query"
            
            # OSV query format
            if version:
                query_data = {
                    "package": {
                        "name": service.lower()
                    },
                    "version": version
                }
            else:
                # For no version, use broader ecosystem search
                query_data = {
                    "package": {
                        "name": service.lower()
                    }
                }
            
            response = self.session.post(url, json=query_data, timeout=10)
            
            if response.status_code != 200:
                return {'vulnerabilities': []}
            
            data = response.json()
            vulnerabilities = []
            
            if 'vulns' in data:
                for vuln_item in data['vulns'][:15]:  # Limit results
                    # Extract severity info
                    severity_info = vuln_item.get('severity', [])
                    cvss_score = 0.0
                    
                    for sev in severity_info:
                        if sev.get('type') == 'CVSS_V3':
                            cvss_score = float(sev.get('score', 0))
                            break
                        elif sev.get('type') == 'CVSS_V2':
                            cvss_score = float(sev.get('score', 0))
                    
                    vuln = {
                        'id': vuln_item.get('id', ''),
                        'description': vuln_item.get('summary', ''),
                        'cvss_score': cvss_score,
                        'published_date': vuln_item.get('published', ''),
                        'modified_date': vuln_item.get('modified', ''),
                        'source': 'OSV_Google',
                        'references': [ref.get('url', '') for ref in vuln_item.get('references', [])],
                        'severity': self._get_severity_from_cvss(cvss_score),
                        'affected_versions': [affected.get('versions', []) for affected in vuln_item.get('affected', [])]
                    }
                    
                    vulnerabilities.append(vuln)
            
            print(f"  ğŸ“Š OSV returned {len(vulnerabilities)} vulnerabilities")
            return {'vulnerabilities': vulnerabilities}
            
        except Exception as e:
            print(f"âŒ OSV query error: {e}")
            return {'vulnerabilities': []}
    
    def _query_vulndb_api(self, service: str, version: str = None, port: int = None, 
                         banner: str = None) -> Dict[str, Any]:
        """
        Query VulnDB free API endpoints
        """
        self._rate_limit('vulndb', 1.0)
        
        try:
            # Use the free search endpoint
            search_url = "https://vuldb.com/api/v1/search/"
            
            # Build search query
            search_query = service.lower()
            if version:
                search_query += f" {version}"
            
            params = {
                'search': search_query,
                'format': 'json'
            }
            
            response = self.session.get(search_url, params=params, timeout=10)
            
            # VulnDB often returns HTML even for API calls, so check content type
            if 'application/json' not in response.headers.get('content-type', ''):
                return {'vulnerabilities': []}
            
            data = response.json()
            vulnerabilities = []
            
            if isinstance(data, dict) and 'entries' in data:
                for entry in data['entries'][:10]:
                    vuln = {
                        'id': entry.get('id', ''),
                        'description': entry.get('title', ''),
                        'cvss_score': float(entry.get('cvss_score', 0)) if entry.get('cvss_score') else 0.0,
                        'published_date': entry.get('published', ''),
                        'source': 'VulnDB',
                        'severity': self._get_severity_from_cvss(float(entry.get('cvss_score', 0)) if entry.get('cvss_score') else 0.0)
                    }
                    vulnerabilities.append(vuln)
            
            print(f"  ğŸ“Š VulnDB returned {len(vulnerabilities)} vulnerabilities")
            return {'vulnerabilities': vulnerabilities}
            
        except Exception as e:
            print(f"âŒ VulnDB query error: {e}")
            return {'vulnerabilities': []}
    
    def _query_cisa_kev(self, service: str, version: str = None, port: int = None, 
                       banner: str = None) -> Dict[str, Any]:
        """
        Query CISA Known Exploited Vulnerabilities - Critical ones only
        """
        if not self.cisa_kev_loaded:
            self._load_cisa_kev_data()
        
        try:
            vulnerabilities = []
            
            if not self.cisa_kev_cache:
                return {'vulnerabilities': vulnerabilities}
            
            service_lower = service.lower() if service else ""
            version_lower = version.lower() if version else ""
            
            for kev_item in self.cisa_kev_cache:
                # Improved matching logic
                vuln_name = kev_item.get('vulnerabilityName', '').lower()
                product = kev_item.get('product', '').lower()
                vendor = kev_item.get('vendorProject', '').lower()
                
                # Check if this KEV relates to our service
                matches = (
                    service_lower in vuln_name or 
                    service_lower in product or 
                    service_lower in vendor or
                    any(service_lower in word for word in vuln_name.split()) or
                    any(service_lower in word for word in product.split())
                )
                
                if matches:
                    # If version specified, try to match it too
                    version_matches = True
                    if version:
                        version_matches = (
                            version_lower in vuln_name or
                            version_lower in product or
                            any(version_lower in word for word in vuln_name.split())
                        )
                    
                    if version_matches:
                        vuln = {
                            'id': kev_item.get('cveID', ''),
                            'description': kev_item.get('vulnerabilityName', ''),
                            'cvss_score': 9.5,  # KEV items are high priority by definition
                            'published_date': kev_item.get('dateAdded', ''),
                            'due_date': kev_item.get('dueDate', ''),
                            'source': 'CISA_KEV',
                            'exploited_in_wild': True,
                            'severity': 'CRITICAL',
                            'required_action': kev_item.get('requiredAction', ''),
                            'product': product,
                            'vendor': vendor
                        }
                        vulnerabilities.append(vuln)
            
            print(f"  ğŸ“Š CISA KEV returned {len(vulnerabilities)} vulnerabilities")
            return {'vulnerabilities': vulnerabilities}
            
        except Exception as e:
            print(f"âŒ CISA KEV error: {e}")
            return {'vulnerabilities': []}
    
    def _load_cisa_kev_data(self):
        """Load CISA KEV data once and cache it"""
        try:
            self._rate_limit('cisa_kev_load', 2.0)
            url = "https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json"
            response = self.session.get(url, timeout=15)
            response.raise_for_status()
            
            data = response.json()
            self.cisa_kev_cache = data.get('vulnerabilities', [])
            self.cisa_kev_loaded = True
            print(f"  âœ… Loaded {len(self.cisa_kev_cache)} CISA KEV entries")
            
        except Exception as e:
            print(f"âŒ Failed to load CISA KEV data: {e}")
            self.cisa_kev_cache = []
            self.cisa_kev_loaded = True
    
    def _get_top_recent_vulnerabilities(self, vulnerabilities: List[Dict], limit: int = 5) -> List[Dict]:
        """
        Get top N most recent vulnerabilities when version is not available
        """
        # Sort by published date (most recent first) and CVSS score
        def sort_key(vuln):
            pub_date = vuln.get('published_date', '')
            cvss = vuln.get('cvss_score', 0)
            
            # Parse date for sorting
            try:
                if pub_date:
                    # Handle different date formats
                    for fmt in ['%Y-%m-%dT%H:%M:%S.%fZ', '%Y-%m-%dT%H:%M:%SZ', '%Y-%m-%d']:
                        try:
                            parsed_date = datetime.strptime(pub_date.split('T')[0], '%Y-%m-%d')
                            return (parsed_date, cvss)
                        except:
                            continue
                return (datetime.min, cvss)
            except:
                return (datetime.min, cvss)
        
        sorted_vulns = sorted(vulnerabilities, key=sort_key, reverse=True)
        return sorted_vulns[:limit]
    
    def _get_severity_from_cvss(self, cvss_score: float) -> str:
        """Convert CVSS score to severity level (CVSS v3.1 standard)"""
        if cvss_score >= 9.0:
            return "CRITICAL"
        elif cvss_score >= 7.0:
            return "HIGH"
        elif cvss_score >= 4.0:
            return "MEDIUM"
        elif cvss_score > 0.0:
            return "LOW"
        else:
            return "INFO"
    
    def _deduplicate_vulnerabilities(self, vulnerabilities: List[Dict]) -> List[Dict]:
        """
        Improved deduplication with better merging logic
        """
        seen_cves = {}
        
        for vuln in vulnerabilities:
            cve_id = vuln.get('id', '')
            if not cve_id:
                continue
                
            if cve_id not in seen_cves:
                seen_cves[cve_id] = vuln
            else:
                # Merge information from multiple sources
                existing = seen_cves[cve_id]
                
                # Keep the one with higher CVSS score
                if vuln.get('cvss_score', 0) > existing.get('cvss_score', 0):
                    seen_cves[cve_id] = vuln
                
                # Merge references
                existing_refs = set(existing.get('references', []))
                new_refs = set(vuln.get('references', []))
                merged_refs = list(existing_refs.union(new_refs))
                seen_cves[cve_id]['references'] = merged_refs
                
                # Keep the longer description
                if len(str(vuln.get('description', ''))) > len(str(existing.get('description', ''))):
                    seen_cves[cve_id]['description'] = vuln.get('description', '')
        
        # Sort by CVSS score (highest first), then by date
        def sort_key(vuln):
            cvss = vuln.get('cvss_score', 0)
            pub_date = vuln.get('published_date', '')
            
            # Parse date for sorting
            try:
                if pub_date:
                    parsed_date = datetime.strptime(pub_date.split('T')[0], '%Y-%m-%d')
                    return (cvss, parsed_date)
            except:
                pass
            
            return (cvss, datetime.min)
        
        sorted_vulns = sorted(seen_cves.values(), key=sort_key, reverse=True)
        return sorted_vulns


def enhanced_vulnerability_scan(hosts):
    """
    Enhanced vulnerability scanning with improved data collection
    """
    vuln_scanner = MultiSourceVulnerabilityScanner()
    
    total_vulns_found = 0
    critical_vulns = 0
    high_vulns = 0
    
    for host in hosts:
        ip = host["ip"]
        print(f"\nğŸ  Scanning vulnerabilities for host: {ip}")
        print(f"{'='*60}")
        
        for svc in host["services"]:
            port = svc["port"]
            service = svc.get("service") or svc.get("product", "") or svc.get("name", "")
            version = svc.get("version", "")
            banner = svc.get("banner", "")
            
            if not service:
                print(f"  âš ï¸  Port {port}: No service identified, skipping vulnerability scan")
                continue
            
            print(f"\n  ğŸ¯ Port {port} ({service} {version or 'version unknown'})")
            print(f"  {'â”€'*50}")
            
            # Scan vulnerabilities using multiple sources
            vuln_results = vuln_scanner.scan_vulnerabilities(
                service=service,
                version=version,
                port=port,
                banner=banner
            )
            
            # Add results to service
            svc["vulnerabilities"] = vuln_results["vulnerabilities"]
            svc["vuln_sources"] = vuln_results["sources_used"]
            svc["vuln_confidence"] = vuln_results["confidence"]
            svc["vuln_count"] = vuln_results["total_found"]
            svc["search_strategy"] = vuln_results["search_strategy"]
            
            total_vulns_found += vuln_results["total_found"]
            
            # Count severity levels
            for vuln in vuln_results["vulnerabilities"]:
                severity = vuln.get('severity', '')
                if severity == 'CRITICAL':
                    critical_vulns += 1
                elif severity == 'HIGH':
                    high_vulns += 1
            
            # Print detailed summary
            if vuln_results["total_found"] > 0:
                print(f"  âœ… Found {vuln_results['total_found']} vulnerabilities")
                print(f"  ğŸ“Š Sources: {', '.join(vuln_results['sources_used'])}")
                print(f"  ğŸ¯ Confidence: {vuln_results['confidence'].upper()}")
                print(f"  ğŸ” Strategy: {vuln_results['search_strategy']}")
                
                # Show top 3 vulnerabilities
                top_vulns = vuln_results["vulnerabilities"][:3]
                for i, vuln in enumerate(top_vulns, 1):
                    severity_emoji = {
                        'CRITICAL': 'ğŸ”´',
                        'HIGH': 'ğŸŸ ', 
                        'MEDIUM': 'ğŸŸ¡',
                        'LOW': 'ğŸŸ¢',
                        'INFO': 'ğŸ”µ'
                    }.get(vuln.get('severity', 'INFO'), 'âšª')
                    
                    print(f"    {severity_emoji} #{i}: {vuln['id']} (CVSS: {vuln.get('cvss_score', 'N/A')}) - {vuln.get('severity', 'UNKNOWN')}")
                    if vuln.get('exploited_in_wild'):
                        print(f"        ğŸš¨ ACTIVELY EXPLOITED IN THE WILD!")
                    
                    # Truncate long descriptions
                    desc = vuln.get('description', '')
                    if len(desc) > 100:
                        desc = desc[:100] + "..."
                    print(f"        ğŸ“ {desc}")
            else:
                print(f"  â„¹ï¸  No vulnerabilities found")
                
                # Suggest alternative searches if no results
                if version:
                    print(f"    ğŸ’¡ Try searching without version for general {service} vulnerabilities")
    
    # Final summary
    print(f"\n{'='*60}")
    print(f"ğŸ“ˆ VULNERABILITY SCAN SUMMARY")
    print(f"{'='*60}")
    print(f"ğŸ” Total vulnerabilities found: {total_vulns_found}")
    print(f"ğŸ”´ Critical vulnerabilities: {critical_vulns}")
    print(f"ğŸŸ  High severity vulnerabilities: {high_vulns}")
    
    if critical_vulns > 0:
        print(f"ğŸš¨ URGENT: {critical_vulns} critical vulnerabilities require immediate attention!")
    elif high_vulns > 0:
        print(f"âš ï¸  WARNING: {high_vulns} high severity vulnerabilities found")
    
    return hosts


# Utility function to test a single service
def test_vulnerability_scan(service: str, version: str = None):
    """
    Test vulnerability scanning for a single service
    """
    scanner = MultiSourceVulnerabilityScanner()
    
    print(f"ğŸ§ª Testing vulnerability scan for: {service} {version or '(no version)'}")
    print(f"{'='*60}")
    
    results = scanner.scan_vulnerabilities(service, version)
    
    print(f"\nğŸ“Š RESULTS:")
    print(f"Total found: {results['total_found']}")
    print(f"Sources used: {', '.join(results['sources_used'])}")
    print(f"Confidence: {results['confidence']}")
    print(f"Search strategy: {results['search_strategy']}")
    
    if results['vulnerabilities']:
        print(f"\nğŸ” Top vulnerabilities:")
        for i, vuln in enumerate(results['vulnerabilities'][:5], 1):
            severity_emoji = {
                'CRITICAL': 'ğŸ”´',
                'HIGH': 'ğŸŸ ', 
                'MEDIUM': 'ğŸŸ¡',
                'LOW': 'ğŸŸ¢',
                'INFO': 'ğŸ”µ'
            }.get(vuln.get('severity', 'INFO'), 'âšª')
            
            print(f"  {severity_emoji} {i}. {vuln['id']} - {vuln.get('severity', 'UNKNOWN')}")
            print(f"     CVSS: {vuln.get('cvss_score', 'N/A')} | Source: {vuln.get('source', 'Unknown')}")
            
            desc = vuln.get('description', 'No description available')
            if len(desc) > 120:
                desc = desc[:120] + "..."
            print(f"     ğŸ“ {desc}")
            
            if vuln.get('exploited_in_wild'):
                print(f"     ğŸš¨ ACTIVELY EXPLOITED!")
            
            print()
    else:
        print(f"\nâœ… No vulnerabilities found for {service}")
    
    return results


# Example usage and testing
if __name__ == "__main__":
    # Test with common services
    test_cases = [
        ("apache", "2.4.41"),  # Specific version
        ("nginx", "1.18.0"),   # Specific version  
        ("openssh", None),     # No version - should get recent CVEs
        ("mysql", None),       # No version - should get recent CVEs
        ("wordpress", "5.8"),  # Web application
    ]
    
    print("ğŸš€ Starting Enhanced Vulnerability Scanner Tests")
    print("="*70)
    
    for service, version in test_cases:
        print(f"\n{'ğŸ”¬ Testing: ' + service + (' ' + version if version else ' (no version)')}")
        print("â”€" * 70)
        
        results = test_vulnerability_scan(service, version)
        
        if results['total_found'] > 0:
            critical_count = sum(1 for v in results['vulnerabilities'] if v.get('severity') == 'CRITICAL')
            high_count = sum(1 for v in results['vulnerabilities'] if v.get('severity') == 'HIGH')
            
            if critical_count > 0:
                print(f"ğŸš¨ {critical_count} CRITICAL vulnerabilities found!")
            if high_count > 0:
                print(f"âš ï¸  {high_count} HIGH severity vulnerabilities found!")
        
        print("\n" + "â”€" * 70)
        time.sleep(2)  # Pause between tests
    
    print("\nâœ… All tests completed!")


# Advanced vulnerability analysis functions
class VulnerabilityAnalyzer:
    """Additional analysis tools for vulnerability data"""
    
    @staticmethod
    def analyze_vulnerability_trends(hosts: List[Dict]) -> Dict[str, Any]:
        """Analyze vulnerability trends across all scanned hosts"""
        
        all_vulns = []
        service_vuln_count = {}
        severity_distribution = {'CRITICAL': 0, 'HIGH': 0, 'MEDIUM': 0, 'LOW': 0, 'INFO': 0}
        exploited_vulns = []
        
        for host in hosts:
            for service in host.get('services', []):
                service_name = service.get('service', 'unknown')
                vulns = service.get('vulnerabilities', [])
                
                all_vulns.extend(vulns)
                service_vuln_count[service_name] = service_vuln_count.get(service_name, 0) + len(vulns)
                
                for vuln in vulns:
                    severity = vuln.get('severity', 'INFO')
                    severity_distribution[severity] = severity_distribution.get(severity, 0) + 1
                    
                    if vuln.get('exploited_in_wild'):
                        exploited_vulns.append(vuln)
        
        # Find most vulnerable services
        most_vulnerable = sorted(service_vuln_count.items(), key=lambda x: x[1], reverse=True)
        
        # Calculate risk score
        risk_score = (
            severity_distribution['CRITICAL'] * 10 +
            severity_distribution['HIGH'] * 7 +
            severity_distribution['MEDIUM'] * 4 +
            severity_distribution['LOW'] * 1
        )
        
        return {
            'total_vulnerabilities': len(all_vulns),
            'severity_distribution': severity_distribution,
            'most_vulnerable_services': most_vulnerable[:5],
            'exploited_in_wild_count': len(exploited_vulns),
            'risk_score': risk_score,
            'exploited_vulnerabilities': exploited_vulns,
            'recommendations': VulnerabilityAnalyzer._generate_recommendations(
                severity_distribution, exploited_vulns, most_vulnerable
            )
        }
    
    @staticmethod
    def _generate_recommendations(severity_dist: Dict, exploited_vulns: List, vulnerable_services: List) -> List[str]:
        """Generate actionable recommendations based on vulnerability analysis"""
        
        recommendations = []
        
        if severity_dist.get('CRITICAL', 0) > 0:
            recommendations.append(
                f"ğŸš¨ IMMEDIATE ACTION: {severity_dist['CRITICAL']} critical vulnerabilities require urgent patching"
            )
        
        if exploited_vulns:
            recommendations.append(
                f"ğŸ”¥ PRIORITY: {len(exploited_vulns)} vulnerabilities are being actively exploited in the wild"
            )
        
        if vulnerable_services:
            top_service = vulnerable_services[0]
            recommendations.append(
                f"ğŸ¯ Focus on {top_service[0]} - most vulnerable service with {top_service[1]} vulnerabilities"
            )
        
        if severity_dist.get('HIGH', 0) > 5:
            recommendations.append(
                "âš ï¸  High number of HIGH severity vulnerabilities - implement a patching schedule"
            )
        
        total_vulns = sum(severity_dist.values())
        if total_vulns > 20:
            recommendations.append(
                "ğŸ“‹ Consider implementing vulnerability management tools and automated scanning"
            )
        
        if not recommendations:
            recommendations.append("âœ… Good security posture - continue regular vulnerability assessments")
        
        return recommendations
    
    @staticmethod
    def export_vulnerability_report(hosts: List[Dict], filename: str = "vulnerability_report.json"):
        """Export detailed vulnerability report"""
        
        report_data = {
            'scan_timestamp': datetime.now().isoformat(),
            'summary': VulnerabilityAnalyzer.analyze_vulnerability_trends(hosts),
            'detailed_results': hosts
        }
        
        try:
            with open(filename, 'w') as f:
                json.dump(report_data, f, indent=2)
            print(f"ğŸ“„ Vulnerability report exported to: {filename}")
        except Exception as e:
            print(f"âŒ Failed to export report: {e}")
        
        return report_data


# Example integration with enhanced reporting
def comprehensive_vulnerability_assessment(hosts):
    """
    Complete vulnerability assessment with analysis and reporting
    """
    print("ğŸš€ Starting Comprehensive Vulnerability Assessment")
    print("=" * 70)
    
    # Enhanced vulnerability scanning
    scanned_hosts = enhanced_vulnerability_scan(hosts)
    
    # Analyze trends and generate insights
    analysis = VulnerabilityAnalyzer.analyze_vulnerability_trends(scanned_hosts)
    
    # Print analysis summary
    print(f"\nğŸ“Š VULNERABILITY ANALYSIS SUMMARY")
    print("=" * 70)
    print(f"ğŸ” Total vulnerabilities: {analysis['total_vulnerabilities']}")
    print(f"ğŸ”´ Critical: {analysis['severity_distribution']['CRITICAL']}")
    print(f"ğŸŸ  High: {analysis['severity_distribution']['HIGH']}")
    print(f"ğŸŸ¡ Medium: {analysis['severity_distribution']['MEDIUM']}")
    print(f"ğŸŸ¢ Low: {analysis['severity_distribution']['LOW']}")
    print(f"ğŸ”¥ Actively exploited: {analysis['exploited_in_wild_count']}")
    print(f"ğŸ“ˆ Risk Score: {analysis['risk_score']}")
    
    if analysis['most_vulnerable_services']:
        print(f"\nğŸ¯ Most Vulnerable Services:")
        for service, count in analysis['most_vulnerable_services']:
            print(f"   â€¢ {service}: {count} vulnerabilities")
    
    print(f"\nğŸ’¡ RECOMMENDATIONS:")
    for rec in analysis['recommendations']:
        print(f"   â€¢ {rec}")
    
    # Export report
    VulnerabilityAnalyzer.export_vulnerability_report(scanned_hosts)
    
    return scanned_hosts, analysis